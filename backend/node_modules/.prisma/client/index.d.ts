
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Loans
 * 
 */
export type Loans = $Result.DefaultSelection<Prisma.$LoansPayload>
/**
 * Model LoanPayment
 * 
 */
export type LoanPayment = $Result.DefaultSelection<Prisma.$LoanPaymentPayload>
/**
 * Model Deposits
 * 
 */
export type Deposits = $Result.DefaultSelection<Prisma.$DepositsPayload>
/**
 * Model Cards
 * 
 */
export type Cards = $Result.DefaultSelection<Prisma.$CardsPayload>
/**
 * Model CardTransaction
 * 
 */
export type CardTransaction = $Result.DefaultSelection<Prisma.$CardTransactionPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ChatMessages
 * const chatMessages = await prisma.chatMessage.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ChatMessages
   * const chatMessages = await prisma.chatMessage.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loans`: Exposes CRUD operations for the **Loans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loans
    * const loans = await prisma.loans.findMany()
    * ```
    */
  get loans(): Prisma.LoansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loanPayment`: Exposes CRUD operations for the **LoanPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanPayments
    * const loanPayments = await prisma.loanPayment.findMany()
    * ```
    */
  get loanPayment(): Prisma.LoanPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deposits`: Exposes CRUD operations for the **Deposits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deposits
    * const deposits = await prisma.deposits.findMany()
    * ```
    */
  get deposits(): Prisma.DepositsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cards`: Exposes CRUD operations for the **Cards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.cards.findMany()
    * ```
    */
  get cards(): Prisma.CardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardTransaction`: Exposes CRUD operations for the **CardTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardTransactions
    * const cardTransactions = await prisma.cardTransaction.findMany()
    * ```
    */
  get cardTransaction(): Prisma.CardTransactionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ChatMessage: 'ChatMessage',
    Users: 'Users',
    Loans: 'Loans',
    LoanPayment: 'LoanPayment',
    Deposits: 'Deposits',
    Cards: 'Cards',
    CardTransaction: 'CardTransaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "chatMessage" | "users" | "loans" | "loanPayment" | "deposits" | "cards" | "cardTransaction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Loans: {
        payload: Prisma.$LoansPayload<ExtArgs>
        fields: Prisma.LoansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload>
          }
          findFirst: {
            args: Prisma.LoansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload>
          }
          findMany: {
            args: Prisma.LoansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload>[]
          }
          create: {
            args: Prisma.LoansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload>
          }
          createMany: {
            args: Prisma.LoansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload>[]
          }
          delete: {
            args: Prisma.LoansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload>
          }
          update: {
            args: Prisma.LoansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload>
          }
          deleteMany: {
            args: Prisma.LoansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoansUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload>[]
          }
          upsert: {
            args: Prisma.LoansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoansPayload>
          }
          aggregate: {
            args: Prisma.LoansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoans>
          }
          groupBy: {
            args: Prisma.LoansGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoansGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoansCountArgs<ExtArgs>
            result: $Utils.Optional<LoansCountAggregateOutputType> | number
          }
        }
      }
      LoanPayment: {
        payload: Prisma.$LoanPaymentPayload<ExtArgs>
        fields: Prisma.LoanPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          findFirst: {
            args: Prisma.LoanPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          findMany: {
            args: Prisma.LoanPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>[]
          }
          create: {
            args: Prisma.LoanPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          createMany: {
            args: Prisma.LoanPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>[]
          }
          delete: {
            args: Prisma.LoanPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          update: {
            args: Prisma.LoanPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          deleteMany: {
            args: Prisma.LoanPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoanPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>[]
          }
          upsert: {
            args: Prisma.LoanPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPaymentPayload>
          }
          aggregate: {
            args: Prisma.LoanPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoanPayment>
          }
          groupBy: {
            args: Prisma.LoanPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<LoanPaymentCountAggregateOutputType> | number
          }
        }
      }
      Deposits: {
        payload: Prisma.$DepositsPayload<ExtArgs>
        fields: Prisma.DepositsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepositsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepositsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload>
          }
          findFirst: {
            args: Prisma.DepositsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepositsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload>
          }
          findMany: {
            args: Prisma.DepositsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload>[]
          }
          create: {
            args: Prisma.DepositsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload>
          }
          createMany: {
            args: Prisma.DepositsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepositsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload>[]
          }
          delete: {
            args: Prisma.DepositsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload>
          }
          update: {
            args: Prisma.DepositsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload>
          }
          deleteMany: {
            args: Prisma.DepositsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepositsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepositsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload>[]
          }
          upsert: {
            args: Prisma.DepositsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositsPayload>
          }
          aggregate: {
            args: Prisma.DepositsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeposits>
          }
          groupBy: {
            args: Prisma.DepositsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepositsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepositsCountArgs<ExtArgs>
            result: $Utils.Optional<DepositsCountAggregateOutputType> | number
          }
        }
      }
      Cards: {
        payload: Prisma.$CardsPayload<ExtArgs>
        fields: Prisma.CardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload>
          }
          findFirst: {
            args: Prisma.CardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload>
          }
          findMany: {
            args: Prisma.CardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload>[]
          }
          create: {
            args: Prisma.CardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload>
          }
          createMany: {
            args: Prisma.CardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload>[]
          }
          delete: {
            args: Prisma.CardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload>
          }
          update: {
            args: Prisma.CardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload>
          }
          deleteMany: {
            args: Prisma.CardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CardsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload>[]
          }
          upsert: {
            args: Prisma.CardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardsPayload>
          }
          aggregate: {
            args: Prisma.CardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCards>
          }
          groupBy: {
            args: Prisma.CardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardsCountArgs<ExtArgs>
            result: $Utils.Optional<CardsCountAggregateOutputType> | number
          }
        }
      }
      CardTransaction: {
        payload: Prisma.$CardTransactionPayload<ExtArgs>
        fields: Prisma.CardTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload>
          }
          findFirst: {
            args: Prisma.CardTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload>
          }
          findMany: {
            args: Prisma.CardTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload>[]
          }
          create: {
            args: Prisma.CardTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload>
          }
          createMany: {
            args: Prisma.CardTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload>[]
          }
          delete: {
            args: Prisma.CardTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload>
          }
          update: {
            args: Prisma.CardTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CardTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CardTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload>[]
          }
          upsert: {
            args: Prisma.CardTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardTransactionPayload>
          }
          aggregate: {
            args: Prisma.CardTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardTransaction>
          }
          groupBy: {
            args: Prisma.CardTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CardTransactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    chatMessage?: ChatMessageOmit
    users?: UsersOmit
    loans?: LoansOmit
    loanPayment?: LoanPaymentOmit
    deposits?: DepositsOmit
    cards?: CardsOmit
    cardTransaction?: CardTransactionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    Loans: number
    Deposits: number
    Cards: number
    SentMessages: number
    ReceivedMessages: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Loans?: boolean | UsersCountOutputTypeCountLoansArgs
    Deposits?: boolean | UsersCountOutputTypeCountDepositsArgs
    Cards?: boolean | UsersCountOutputTypeCountCardsArgs
    SentMessages?: boolean | UsersCountOutputTypeCountSentMessagesArgs
    ReceivedMessages?: boolean | UsersCountOutputTypeCountReceivedMessagesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLoansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoansWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type LoansCountOutputType
   */

  export type LoansCountOutputType = {
    LoanPayments: number
  }

  export type LoansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LoanPayments?: boolean | LoansCountOutputTypeCountLoanPaymentsArgs
  }

  // Custom InputTypes
  /**
   * LoansCountOutputType without action
   */
  export type LoansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoansCountOutputType
     */
    select?: LoansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoansCountOutputType without action
   */
  export type LoansCountOutputTypeCountLoanPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanPaymentWhereInput
  }


  /**
   * Count Type CardsCountOutputType
   */

  export type CardsCountOutputType = {
    SentTransactions: number
    ReceivedTransactions: number
  }

  export type CardsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SentTransactions?: boolean | CardsCountOutputTypeCountSentTransactionsArgs
    ReceivedTransactions?: boolean | CardsCountOutputTypeCountReceivedTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CardsCountOutputType without action
   */
  export type CardsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardsCountOutputType
     */
    select?: CardsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardsCountOutputType without action
   */
  export type CardsCountOutputTypeCountSentTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardTransactionWhereInput
  }

  /**
   * CardsCountOutputType without action
   */
  export type CardsCountOutputTypeCountReceivedTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardTransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type ChatMessageSumAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    content: string | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    createdAt: number
    _all: number
  }


  export type ChatMessageAvgAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type ChatMessageSumAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type ChatMessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _avg?: ChatMessageAvgAggregateInputType
    _sum?: ChatMessageSumAggregateInputType
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: string
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    createdAt?: boolean
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    createdAt?: boolean
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    createdAt?: boolean
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "content" | "createdAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UsersDefaultArgs<ExtArgs>
    Receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      Sender: Prisma.$UsersPayload<ExtArgs>
      Receiver: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      senderId: number
      receiverId: number
      content: string
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Sender<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Receiver<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'Int'>
    readonly senderId: FieldRef<"ChatMessage", 'Int'>
    readonly receiverId: FieldRef<"ChatMessage", 'Int'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone_number: string | null
    password_hash: string | null
    role: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone_number: string | null
    password_hash: string | null
    role: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone_number: number
    password_hash: number
    role: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone_number?: true
    password_hash?: true
    role?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone_number?: true
    password_hash?: true
    role?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone_number?: true
    password_hash?: true
    role?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    name: string
    email: string
    phone_number: string
    password_hash: string
    role: string
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone_number?: boolean
    password_hash?: boolean
    role?: boolean
    Loans?: boolean | Users$LoansArgs<ExtArgs>
    Deposits?: boolean | Users$DepositsArgs<ExtArgs>
    Cards?: boolean | Users$CardsArgs<ExtArgs>
    SentMessages?: boolean | Users$SentMessagesArgs<ExtArgs>
    ReceivedMessages?: boolean | Users$ReceivedMessagesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone_number?: boolean
    password_hash?: boolean
    role?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone_number?: boolean
    password_hash?: boolean
    role?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone_number?: boolean
    password_hash?: boolean
    role?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone_number" | "password_hash" | "role", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Loans?: boolean | Users$LoansArgs<ExtArgs>
    Deposits?: boolean | Users$DepositsArgs<ExtArgs>
    Cards?: boolean | Users$CardsArgs<ExtArgs>
    SentMessages?: boolean | Users$SentMessagesArgs<ExtArgs>
    ReceivedMessages?: boolean | Users$ReceivedMessagesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      Loans: Prisma.$LoansPayload<ExtArgs>[]
      Deposits: Prisma.$DepositsPayload<ExtArgs>[]
      Cards: Prisma.$CardsPayload<ExtArgs>[]
      SentMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
      ReceivedMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone_number: string
      password_hash: string
      role: string
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Loans<T extends Users$LoansArgs<ExtArgs> = {}>(args?: Subset<T, Users$LoansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Deposits<T extends Users$DepositsArgs<ExtArgs> = {}>(args?: Subset<T, Users$DepositsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Cards<T extends Users$CardsArgs<ExtArgs> = {}>(args?: Subset<T, Users$CardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SentMessages<T extends Users$SentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Users$SentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ReceivedMessages<T extends Users$ReceivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Users$ReceivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'Int'>
    readonly name: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly phone_number: FieldRef<"Users", 'String'>
    readonly password_hash: FieldRef<"Users", 'String'>
    readonly role: FieldRef<"Users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.Loans
   */
  export type Users$LoansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
    where?: LoansWhereInput
    orderBy?: LoansOrderByWithRelationInput | LoansOrderByWithRelationInput[]
    cursor?: LoansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoansScalarFieldEnum | LoansScalarFieldEnum[]
  }

  /**
   * Users.Deposits
   */
  export type Users$DepositsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
    where?: DepositsWhereInput
    orderBy?: DepositsOrderByWithRelationInput | DepositsOrderByWithRelationInput[]
    cursor?: DepositsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepositsScalarFieldEnum | DepositsScalarFieldEnum[]
  }

  /**
   * Users.Cards
   */
  export type Users$CardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
    where?: CardsWhereInput
    orderBy?: CardsOrderByWithRelationInput | CardsOrderByWithRelationInput[]
    cursor?: CardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardsScalarFieldEnum | CardsScalarFieldEnum[]
  }

  /**
   * Users.SentMessages
   */
  export type Users$SentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * Users.ReceivedMessages
   */
  export type Users$ReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Loans
   */

  export type AggregateLoans = {
    _count: LoansCountAggregateOutputType | null
    _avg: LoansAvgAggregateOutputType | null
    _sum: LoansSumAggregateOutputType | null
    _min: LoansMinAggregateOutputType | null
    _max: LoansMaxAggregateOutputType | null
  }

  export type LoansAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
    interest_rate: number | null
    term: number | null
    monthly_payment_amount: number | null
    outstanding_principal: number | null
    paid_amount: number | null
    accrued_penalty: number | null
  }

  export type LoansSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
    interest_rate: number | null
    term: number | null
    monthly_payment_amount: number | null
    outstanding_principal: number | null
    paid_amount: number | null
    accrued_penalty: number | null
  }

  export type LoansMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
    interest_rate: number | null
    term: number | null
    status: string | null
    created_at: Date | null
    monthly_payment_amount: number | null
    outstanding_principal: number | null
    paid_amount: number | null
    next_payment_due_date: Date | null
    last_payment_date: Date | null
    activated_at: Date | null
    accrued_penalty: number | null
    last_penalty_calculation_date: Date | null
  }

  export type LoansMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
    interest_rate: number | null
    term: number | null
    status: string | null
    created_at: Date | null
    monthly_payment_amount: number | null
    outstanding_principal: number | null
    paid_amount: number | null
    next_payment_due_date: Date | null
    last_payment_date: Date | null
    activated_at: Date | null
    accrued_penalty: number | null
    last_penalty_calculation_date: Date | null
  }

  export type LoansCountAggregateOutputType = {
    id: number
    user_id: number
    amount: number
    interest_rate: number
    term: number
    status: number
    created_at: number
    monthly_payment_amount: number
    outstanding_principal: number
    paid_amount: number
    next_payment_due_date: number
    last_payment_date: number
    activated_at: number
    accrued_penalty: number
    last_penalty_calculation_date: number
    _all: number
  }


  export type LoansAvgAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    interest_rate?: true
    term?: true
    monthly_payment_amount?: true
    outstanding_principal?: true
    paid_amount?: true
    accrued_penalty?: true
  }

  export type LoansSumAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    interest_rate?: true
    term?: true
    monthly_payment_amount?: true
    outstanding_principal?: true
    paid_amount?: true
    accrued_penalty?: true
  }

  export type LoansMinAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    interest_rate?: true
    term?: true
    status?: true
    created_at?: true
    monthly_payment_amount?: true
    outstanding_principal?: true
    paid_amount?: true
    next_payment_due_date?: true
    last_payment_date?: true
    activated_at?: true
    accrued_penalty?: true
    last_penalty_calculation_date?: true
  }

  export type LoansMaxAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    interest_rate?: true
    term?: true
    status?: true
    created_at?: true
    monthly_payment_amount?: true
    outstanding_principal?: true
    paid_amount?: true
    next_payment_due_date?: true
    last_payment_date?: true
    activated_at?: true
    accrued_penalty?: true
    last_penalty_calculation_date?: true
  }

  export type LoansCountAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    interest_rate?: true
    term?: true
    status?: true
    created_at?: true
    monthly_payment_amount?: true
    outstanding_principal?: true
    paid_amount?: true
    next_payment_due_date?: true
    last_payment_date?: true
    activated_at?: true
    accrued_penalty?: true
    last_penalty_calculation_date?: true
    _all?: true
  }

  export type LoansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loans to aggregate.
     */
    where?: LoansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoansOrderByWithRelationInput | LoansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loans
    **/
    _count?: true | LoansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoansMaxAggregateInputType
  }

  export type GetLoansAggregateType<T extends LoansAggregateArgs> = {
        [P in keyof T & keyof AggregateLoans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoans[P]>
      : GetScalarType<T[P], AggregateLoans[P]>
  }




  export type LoansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoansWhereInput
    orderBy?: LoansOrderByWithAggregationInput | LoansOrderByWithAggregationInput[]
    by: LoansScalarFieldEnum[] | LoansScalarFieldEnum
    having?: LoansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoansCountAggregateInputType | true
    _avg?: LoansAvgAggregateInputType
    _sum?: LoansSumAggregateInputType
    _min?: LoansMinAggregateInputType
    _max?: LoansMaxAggregateInputType
  }

  export type LoansGroupByOutputType = {
    id: number
    user_id: number
    amount: number
    interest_rate: number
    term: number
    status: string
    created_at: Date
    monthly_payment_amount: number | null
    outstanding_principal: number | null
    paid_amount: number | null
    next_payment_due_date: Date | null
    last_payment_date: Date | null
    activated_at: Date | null
    accrued_penalty: number | null
    last_penalty_calculation_date: Date | null
    _count: LoansCountAggregateOutputType | null
    _avg: LoansAvgAggregateOutputType | null
    _sum: LoansSumAggregateOutputType | null
    _min: LoansMinAggregateOutputType | null
    _max: LoansMaxAggregateOutputType | null
  }

  type GetLoansGroupByPayload<T extends LoansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoansGroupByOutputType[P]>
            : GetScalarType<T[P], LoansGroupByOutputType[P]>
        }
      >
    >


  export type LoansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    interest_rate?: boolean
    term?: boolean
    status?: boolean
    created_at?: boolean
    monthly_payment_amount?: boolean
    outstanding_principal?: boolean
    paid_amount?: boolean
    next_payment_due_date?: boolean
    last_payment_date?: boolean
    activated_at?: boolean
    accrued_penalty?: boolean
    last_penalty_calculation_date?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    LoanPayments?: boolean | Loans$LoanPaymentsArgs<ExtArgs>
    _count?: boolean | LoansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loans"]>

  export type LoansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    interest_rate?: boolean
    term?: boolean
    status?: boolean
    created_at?: boolean
    monthly_payment_amount?: boolean
    outstanding_principal?: boolean
    paid_amount?: boolean
    next_payment_due_date?: boolean
    last_payment_date?: boolean
    activated_at?: boolean
    accrued_penalty?: boolean
    last_penalty_calculation_date?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loans"]>

  export type LoansSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    interest_rate?: boolean
    term?: boolean
    status?: boolean
    created_at?: boolean
    monthly_payment_amount?: boolean
    outstanding_principal?: boolean
    paid_amount?: boolean
    next_payment_due_date?: boolean
    last_payment_date?: boolean
    activated_at?: boolean
    accrued_penalty?: boolean
    last_penalty_calculation_date?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loans"]>

  export type LoansSelectScalar = {
    id?: boolean
    user_id?: boolean
    amount?: boolean
    interest_rate?: boolean
    term?: boolean
    status?: boolean
    created_at?: boolean
    monthly_payment_amount?: boolean
    outstanding_principal?: boolean
    paid_amount?: boolean
    next_payment_due_date?: boolean
    last_payment_date?: boolean
    activated_at?: boolean
    accrued_penalty?: boolean
    last_penalty_calculation_date?: boolean
  }

  export type LoansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "amount" | "interest_rate" | "term" | "status" | "created_at" | "monthly_payment_amount" | "outstanding_principal" | "paid_amount" | "next_payment_due_date" | "last_payment_date" | "activated_at" | "accrued_penalty" | "last_penalty_calculation_date", ExtArgs["result"]["loans"]>
  export type LoansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    LoanPayments?: boolean | Loans$LoanPaymentsArgs<ExtArgs>
    _count?: boolean | LoansCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoansIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type LoansIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $LoansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Loans"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
      LoanPayments: Prisma.$LoanPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      amount: number
      interest_rate: number
      term: number
      status: string
      created_at: Date
      monthly_payment_amount: number | null
      outstanding_principal: number | null
      paid_amount: number | null
      next_payment_due_date: Date | null
      last_payment_date: Date | null
      activated_at: Date | null
      accrued_penalty: number | null
      last_penalty_calculation_date: Date | null
    }, ExtArgs["result"]["loans"]>
    composites: {}
  }

  type LoansGetPayload<S extends boolean | null | undefined | LoansDefaultArgs> = $Result.GetResult<Prisma.$LoansPayload, S>

  type LoansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoansCountAggregateInputType | true
    }

  export interface LoansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Loans'], meta: { name: 'Loans' } }
    /**
     * Find zero or one Loans that matches the filter.
     * @param {LoansFindUniqueArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoansFindUniqueArgs>(args: SelectSubset<T, LoansFindUniqueArgs<ExtArgs>>): Prisma__LoansClient<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Loans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoansFindUniqueOrThrowArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoansFindUniqueOrThrowArgs>(args: SelectSubset<T, LoansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoansClient<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoansFindFirstArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoansFindFirstArgs>(args?: SelectSubset<T, LoansFindFirstArgs<ExtArgs>>): Prisma__LoansClient<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoansFindFirstOrThrowArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoansFindFirstOrThrowArgs>(args?: SelectSubset<T, LoansFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoansClient<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loans
     * const loans = await prisma.loans.findMany()
     * 
     * // Get first 10 Loans
     * const loans = await prisma.loans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loansWithIdOnly = await prisma.loans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoansFindManyArgs>(args?: SelectSubset<T, LoansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Loans.
     * @param {LoansCreateArgs} args - Arguments to create a Loans.
     * @example
     * // Create one Loans
     * const Loans = await prisma.loans.create({
     *   data: {
     *     // ... data to create a Loans
     *   }
     * })
     * 
     */
    create<T extends LoansCreateArgs>(args: SelectSubset<T, LoansCreateArgs<ExtArgs>>): Prisma__LoansClient<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loans.
     * @param {LoansCreateManyArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loans = await prisma.loans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoansCreateManyArgs>(args?: SelectSubset<T, LoansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Loans and returns the data saved in the database.
     * @param {LoansCreateManyAndReturnArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loans = await prisma.loans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Loans and only return the `id`
     * const loansWithIdOnly = await prisma.loans.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoansCreateManyAndReturnArgs>(args?: SelectSubset<T, LoansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Loans.
     * @param {LoansDeleteArgs} args - Arguments to delete one Loans.
     * @example
     * // Delete one Loans
     * const Loans = await prisma.loans.delete({
     *   where: {
     *     // ... filter to delete one Loans
     *   }
     * })
     * 
     */
    delete<T extends LoansDeleteArgs>(args: SelectSubset<T, LoansDeleteArgs<ExtArgs>>): Prisma__LoansClient<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Loans.
     * @param {LoansUpdateArgs} args - Arguments to update one Loans.
     * @example
     * // Update one Loans
     * const loans = await prisma.loans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoansUpdateArgs>(args: SelectSubset<T, LoansUpdateArgs<ExtArgs>>): Prisma__LoansClient<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loans.
     * @param {LoansDeleteManyArgs} args - Arguments to filter Loans to delete.
     * @example
     * // Delete a few Loans
     * const { count } = await prisma.loans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoansDeleteManyArgs>(args?: SelectSubset<T, LoansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loans
     * const loans = await prisma.loans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoansUpdateManyArgs>(args: SelectSubset<T, LoansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans and returns the data updated in the database.
     * @param {LoansUpdateManyAndReturnArgs} args - Arguments to update many Loans.
     * @example
     * // Update many Loans
     * const loans = await prisma.loans.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Loans and only return the `id`
     * const loansWithIdOnly = await prisma.loans.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoansUpdateManyAndReturnArgs>(args: SelectSubset<T, LoansUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Loans.
     * @param {LoansUpsertArgs} args - Arguments to update or create a Loans.
     * @example
     * // Update or create a Loans
     * const loans = await prisma.loans.upsert({
     *   create: {
     *     // ... data to create a Loans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loans we want to update
     *   }
     * })
     */
    upsert<T extends LoansUpsertArgs>(args: SelectSubset<T, LoansUpsertArgs<ExtArgs>>): Prisma__LoansClient<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoansCountArgs} args - Arguments to filter Loans to count.
     * @example
     * // Count the number of Loans
     * const count = await prisma.loans.count({
     *   where: {
     *     // ... the filter for the Loans we want to count
     *   }
     * })
    **/
    count<T extends LoansCountArgs>(
      args?: Subset<T, LoansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoansAggregateArgs>(args: Subset<T, LoansAggregateArgs>): Prisma.PrismaPromise<GetLoansAggregateType<T>>

    /**
     * Group by Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoansGroupByArgs['orderBy'] }
        : { orderBy?: LoansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Loans model
   */
  readonly fields: LoansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    LoanPayments<T extends Loans$LoanPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Loans$LoanPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Loans model
   */
  interface LoansFieldRefs {
    readonly id: FieldRef<"Loans", 'Int'>
    readonly user_id: FieldRef<"Loans", 'Int'>
    readonly amount: FieldRef<"Loans", 'Float'>
    readonly interest_rate: FieldRef<"Loans", 'Float'>
    readonly term: FieldRef<"Loans", 'Int'>
    readonly status: FieldRef<"Loans", 'String'>
    readonly created_at: FieldRef<"Loans", 'DateTime'>
    readonly monthly_payment_amount: FieldRef<"Loans", 'Float'>
    readonly outstanding_principal: FieldRef<"Loans", 'Float'>
    readonly paid_amount: FieldRef<"Loans", 'Float'>
    readonly next_payment_due_date: FieldRef<"Loans", 'DateTime'>
    readonly last_payment_date: FieldRef<"Loans", 'DateTime'>
    readonly activated_at: FieldRef<"Loans", 'DateTime'>
    readonly accrued_penalty: FieldRef<"Loans", 'Float'>
    readonly last_penalty_calculation_date: FieldRef<"Loans", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Loans findUnique
   */
  export type LoansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
    /**
     * Filter, which Loans to fetch.
     */
    where: LoansWhereUniqueInput
  }

  /**
   * Loans findUniqueOrThrow
   */
  export type LoansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
    /**
     * Filter, which Loans to fetch.
     */
    where: LoansWhereUniqueInput
  }

  /**
   * Loans findFirst
   */
  export type LoansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
    /**
     * Filter, which Loans to fetch.
     */
    where?: LoansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoansOrderByWithRelationInput | LoansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     */
    cursor?: LoansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     */
    distinct?: LoansScalarFieldEnum | LoansScalarFieldEnum[]
  }

  /**
   * Loans findFirstOrThrow
   */
  export type LoansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
    /**
     * Filter, which Loans to fetch.
     */
    where?: LoansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoansOrderByWithRelationInput | LoansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     */
    cursor?: LoansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     */
    distinct?: LoansScalarFieldEnum | LoansScalarFieldEnum[]
  }

  /**
   * Loans findMany
   */
  export type LoansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
    /**
     * Filter, which Loans to fetch.
     */
    where?: LoansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoansOrderByWithRelationInput | LoansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loans.
     */
    cursor?: LoansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    distinct?: LoansScalarFieldEnum | LoansScalarFieldEnum[]
  }

  /**
   * Loans create
   */
  export type LoansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
    /**
     * The data needed to create a Loans.
     */
    data: XOR<LoansCreateInput, LoansUncheckedCreateInput>
  }

  /**
   * Loans createMany
   */
  export type LoansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Loans.
     */
    data: LoansCreateManyInput | LoansCreateManyInput[]
  }

  /**
   * Loans createManyAndReturn
   */
  export type LoansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * The data used to create many Loans.
     */
    data: LoansCreateManyInput | LoansCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loans update
   */
  export type LoansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
    /**
     * The data needed to update a Loans.
     */
    data: XOR<LoansUpdateInput, LoansUncheckedUpdateInput>
    /**
     * Choose, which Loans to update.
     */
    where: LoansWhereUniqueInput
  }

  /**
   * Loans updateMany
   */
  export type LoansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Loans.
     */
    data: XOR<LoansUpdateManyMutationInput, LoansUncheckedUpdateManyInput>
    /**
     * Filter which Loans to update
     */
    where?: LoansWhereInput
    /**
     * Limit how many Loans to update.
     */
    limit?: number
  }

  /**
   * Loans updateManyAndReturn
   */
  export type LoansUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * The data used to update Loans.
     */
    data: XOR<LoansUpdateManyMutationInput, LoansUncheckedUpdateManyInput>
    /**
     * Filter which Loans to update
     */
    where?: LoansWhereInput
    /**
     * Limit how many Loans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loans upsert
   */
  export type LoansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
    /**
     * The filter to search for the Loans to update in case it exists.
     */
    where: LoansWhereUniqueInput
    /**
     * In case the Loans found by the `where` argument doesn't exist, create a new Loans with this data.
     */
    create: XOR<LoansCreateInput, LoansUncheckedCreateInput>
    /**
     * In case the Loans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoansUpdateInput, LoansUncheckedUpdateInput>
  }

  /**
   * Loans delete
   */
  export type LoansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
    /**
     * Filter which Loans to delete.
     */
    where: LoansWhereUniqueInput
  }

  /**
   * Loans deleteMany
   */
  export type LoansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loans to delete
     */
    where?: LoansWhereInput
    /**
     * Limit how many Loans to delete.
     */
    limit?: number
  }

  /**
   * Loans.LoanPayments
   */
  export type Loans$LoanPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    where?: LoanPaymentWhereInput
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    cursor?: LoanPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * Loans without action
   */
  export type LoansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loans
     */
    select?: LoansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loans
     */
    omit?: LoansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoansInclude<ExtArgs> | null
  }


  /**
   * Model LoanPayment
   */

  export type AggregateLoanPayment = {
    _count: LoanPaymentCountAggregateOutputType | null
    _avg: LoanPaymentAvgAggregateOutputType | null
    _sum: LoanPaymentSumAggregateOutputType | null
    _min: LoanPaymentMinAggregateOutputType | null
    _max: LoanPaymentMaxAggregateOutputType | null
  }

  export type LoanPaymentAvgAggregateOutputType = {
    id: number | null
    loan_id: number | null
    amount_paid: number | null
    principal_paid: number | null
    interest_paid: number | null
    outstanding_principal_after_payment: number | null
  }

  export type LoanPaymentSumAggregateOutputType = {
    id: number | null
    loan_id: number | null
    amount_paid: number | null
    principal_paid: number | null
    interest_paid: number | null
    outstanding_principal_after_payment: number | null
  }

  export type LoanPaymentMinAggregateOutputType = {
    id: number | null
    loan_id: number | null
    payment_date: Date | null
    amount_paid: number | null
    principal_paid: number | null
    interest_paid: number | null
    outstanding_principal_after_payment: number | null
    notes: string | null
  }

  export type LoanPaymentMaxAggregateOutputType = {
    id: number | null
    loan_id: number | null
    payment_date: Date | null
    amount_paid: number | null
    principal_paid: number | null
    interest_paid: number | null
    outstanding_principal_after_payment: number | null
    notes: string | null
  }

  export type LoanPaymentCountAggregateOutputType = {
    id: number
    loan_id: number
    payment_date: number
    amount_paid: number
    principal_paid: number
    interest_paid: number
    outstanding_principal_after_payment: number
    notes: number
    _all: number
  }


  export type LoanPaymentAvgAggregateInputType = {
    id?: true
    loan_id?: true
    amount_paid?: true
    principal_paid?: true
    interest_paid?: true
    outstanding_principal_after_payment?: true
  }

  export type LoanPaymentSumAggregateInputType = {
    id?: true
    loan_id?: true
    amount_paid?: true
    principal_paid?: true
    interest_paid?: true
    outstanding_principal_after_payment?: true
  }

  export type LoanPaymentMinAggregateInputType = {
    id?: true
    loan_id?: true
    payment_date?: true
    amount_paid?: true
    principal_paid?: true
    interest_paid?: true
    outstanding_principal_after_payment?: true
    notes?: true
  }

  export type LoanPaymentMaxAggregateInputType = {
    id?: true
    loan_id?: true
    payment_date?: true
    amount_paid?: true
    principal_paid?: true
    interest_paid?: true
    outstanding_principal_after_payment?: true
    notes?: true
  }

  export type LoanPaymentCountAggregateInputType = {
    id?: true
    loan_id?: true
    payment_date?: true
    amount_paid?: true
    principal_paid?: true
    interest_paid?: true
    outstanding_principal_after_payment?: true
    notes?: true
    _all?: true
  }

  export type LoanPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanPayment to aggregate.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanPayments
    **/
    _count?: true | LoanPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanPaymentMaxAggregateInputType
  }

  export type GetLoanPaymentAggregateType<T extends LoanPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanPayment[P]>
      : GetScalarType<T[P], AggregateLoanPayment[P]>
  }




  export type LoanPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanPaymentWhereInput
    orderBy?: LoanPaymentOrderByWithAggregationInput | LoanPaymentOrderByWithAggregationInput[]
    by: LoanPaymentScalarFieldEnum[] | LoanPaymentScalarFieldEnum
    having?: LoanPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanPaymentCountAggregateInputType | true
    _avg?: LoanPaymentAvgAggregateInputType
    _sum?: LoanPaymentSumAggregateInputType
    _min?: LoanPaymentMinAggregateInputType
    _max?: LoanPaymentMaxAggregateInputType
  }

  export type LoanPaymentGroupByOutputType = {
    id: number
    loan_id: number
    payment_date: Date
    amount_paid: number
    principal_paid: number
    interest_paid: number
    outstanding_principal_after_payment: number
    notes: string | null
    _count: LoanPaymentCountAggregateOutputType | null
    _avg: LoanPaymentAvgAggregateOutputType | null
    _sum: LoanPaymentSumAggregateOutputType | null
    _min: LoanPaymentMinAggregateOutputType | null
    _max: LoanPaymentMaxAggregateOutputType | null
  }

  type GetLoanPaymentGroupByPayload<T extends LoanPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], LoanPaymentGroupByOutputType[P]>
        }
      >
    >


  export type LoanPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loan_id?: boolean
    payment_date?: boolean
    amount_paid?: boolean
    principal_paid?: boolean
    interest_paid?: boolean
    outstanding_principal_after_payment?: boolean
    notes?: boolean
    Loan?: boolean | LoansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanPayment"]>

  export type LoanPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loan_id?: boolean
    payment_date?: boolean
    amount_paid?: boolean
    principal_paid?: boolean
    interest_paid?: boolean
    outstanding_principal_after_payment?: boolean
    notes?: boolean
    Loan?: boolean | LoansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanPayment"]>

  export type LoanPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loan_id?: boolean
    payment_date?: boolean
    amount_paid?: boolean
    principal_paid?: boolean
    interest_paid?: boolean
    outstanding_principal_after_payment?: boolean
    notes?: boolean
    Loan?: boolean | LoansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanPayment"]>

  export type LoanPaymentSelectScalar = {
    id?: boolean
    loan_id?: boolean
    payment_date?: boolean
    amount_paid?: boolean
    principal_paid?: boolean
    interest_paid?: boolean
    outstanding_principal_after_payment?: boolean
    notes?: boolean
  }

  export type LoanPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loan_id" | "payment_date" | "amount_paid" | "principal_paid" | "interest_paid" | "outstanding_principal_after_payment" | "notes", ExtArgs["result"]["loanPayment"]>
  export type LoanPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Loan?: boolean | LoansDefaultArgs<ExtArgs>
  }
  export type LoanPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Loan?: boolean | LoansDefaultArgs<ExtArgs>
  }
  export type LoanPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Loan?: boolean | LoansDefaultArgs<ExtArgs>
  }

  export type $LoanPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoanPayment"
    objects: {
      Loan: Prisma.$LoansPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      loan_id: number
      payment_date: Date
      amount_paid: number
      principal_paid: number
      interest_paid: number
      outstanding_principal_after_payment: number
      notes: string | null
    }, ExtArgs["result"]["loanPayment"]>
    composites: {}
  }

  type LoanPaymentGetPayload<S extends boolean | null | undefined | LoanPaymentDefaultArgs> = $Result.GetResult<Prisma.$LoanPaymentPayload, S>

  type LoanPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoanPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoanPaymentCountAggregateInputType | true
    }

  export interface LoanPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanPayment'], meta: { name: 'LoanPayment' } }
    /**
     * Find zero or one LoanPayment that matches the filter.
     * @param {LoanPaymentFindUniqueArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanPaymentFindUniqueArgs>(args: SelectSubset<T, LoanPaymentFindUniqueArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoanPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoanPaymentFindUniqueOrThrowArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindFirstArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanPaymentFindFirstArgs>(args?: SelectSubset<T, LoanPaymentFindFirstArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindFirstOrThrowArgs} args - Arguments to find a LoanPayment
     * @example
     * // Get one LoanPayment
     * const loanPayment = await prisma.loanPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoanPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanPayments
     * const loanPayments = await prisma.loanPayment.findMany()
     * 
     * // Get first 10 LoanPayments
     * const loanPayments = await prisma.loanPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanPaymentWithIdOnly = await prisma.loanPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanPaymentFindManyArgs>(args?: SelectSubset<T, LoanPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoanPayment.
     * @param {LoanPaymentCreateArgs} args - Arguments to create a LoanPayment.
     * @example
     * // Create one LoanPayment
     * const LoanPayment = await prisma.loanPayment.create({
     *   data: {
     *     // ... data to create a LoanPayment
     *   }
     * })
     * 
     */
    create<T extends LoanPaymentCreateArgs>(args: SelectSubset<T, LoanPaymentCreateArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoanPayments.
     * @param {LoanPaymentCreateManyArgs} args - Arguments to create many LoanPayments.
     * @example
     * // Create many LoanPayments
     * const loanPayment = await prisma.loanPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanPaymentCreateManyArgs>(args?: SelectSubset<T, LoanPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoanPayments and returns the data saved in the database.
     * @param {LoanPaymentCreateManyAndReturnArgs} args - Arguments to create many LoanPayments.
     * @example
     * // Create many LoanPayments
     * const loanPayment = await prisma.loanPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoanPayments and only return the `id`
     * const loanPaymentWithIdOnly = await prisma.loanPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoanPayment.
     * @param {LoanPaymentDeleteArgs} args - Arguments to delete one LoanPayment.
     * @example
     * // Delete one LoanPayment
     * const LoanPayment = await prisma.loanPayment.delete({
     *   where: {
     *     // ... filter to delete one LoanPayment
     *   }
     * })
     * 
     */
    delete<T extends LoanPaymentDeleteArgs>(args: SelectSubset<T, LoanPaymentDeleteArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoanPayment.
     * @param {LoanPaymentUpdateArgs} args - Arguments to update one LoanPayment.
     * @example
     * // Update one LoanPayment
     * const loanPayment = await prisma.loanPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanPaymentUpdateArgs>(args: SelectSubset<T, LoanPaymentUpdateArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoanPayments.
     * @param {LoanPaymentDeleteManyArgs} args - Arguments to filter LoanPayments to delete.
     * @example
     * // Delete a few LoanPayments
     * const { count } = await prisma.loanPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanPaymentDeleteManyArgs>(args?: SelectSubset<T, LoanPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanPayments
     * const loanPayment = await prisma.loanPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanPaymentUpdateManyArgs>(args: SelectSubset<T, LoanPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanPayments and returns the data updated in the database.
     * @param {LoanPaymentUpdateManyAndReturnArgs} args - Arguments to update many LoanPayments.
     * @example
     * // Update many LoanPayments
     * const loanPayment = await prisma.loanPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoanPayments and only return the `id`
     * const loanPaymentWithIdOnly = await prisma.loanPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoanPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, LoanPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoanPayment.
     * @param {LoanPaymentUpsertArgs} args - Arguments to update or create a LoanPayment.
     * @example
     * // Update or create a LoanPayment
     * const loanPayment = await prisma.loanPayment.upsert({
     *   create: {
     *     // ... data to create a LoanPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanPayment we want to update
     *   }
     * })
     */
    upsert<T extends LoanPaymentUpsertArgs>(args: SelectSubset<T, LoanPaymentUpsertArgs<ExtArgs>>): Prisma__LoanPaymentClient<$Result.GetResult<Prisma.$LoanPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoanPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentCountArgs} args - Arguments to filter LoanPayments to count.
     * @example
     * // Count the number of LoanPayments
     * const count = await prisma.loanPayment.count({
     *   where: {
     *     // ... the filter for the LoanPayments we want to count
     *   }
     * })
    **/
    count<T extends LoanPaymentCountArgs>(
      args?: Subset<T, LoanPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanPaymentAggregateArgs>(args: Subset<T, LoanPaymentAggregateArgs>): Prisma.PrismaPromise<GetLoanPaymentAggregateType<T>>

    /**
     * Group by LoanPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanPaymentGroupByArgs['orderBy'] }
        : { orderBy?: LoanPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoanPayment model
   */
  readonly fields: LoanPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Loan<T extends LoansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoansDefaultArgs<ExtArgs>>): Prisma__LoansClient<$Result.GetResult<Prisma.$LoansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoanPayment model
   */
  interface LoanPaymentFieldRefs {
    readonly id: FieldRef<"LoanPayment", 'Int'>
    readonly loan_id: FieldRef<"LoanPayment", 'Int'>
    readonly payment_date: FieldRef<"LoanPayment", 'DateTime'>
    readonly amount_paid: FieldRef<"LoanPayment", 'Float'>
    readonly principal_paid: FieldRef<"LoanPayment", 'Float'>
    readonly interest_paid: FieldRef<"LoanPayment", 'Float'>
    readonly outstanding_principal_after_payment: FieldRef<"LoanPayment", 'Float'>
    readonly notes: FieldRef<"LoanPayment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LoanPayment findUnique
   */
  export type LoanPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment findUniqueOrThrow
   */
  export type LoanPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment findFirst
   */
  export type LoanPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanPayments.
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanPayments.
     */
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * LoanPayment findFirstOrThrow
   */
  export type LoanPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayment to fetch.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanPayments.
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanPayments.
     */
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * LoanPayment findMany
   */
  export type LoanPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter, which LoanPayments to fetch.
     */
    where?: LoanPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanPayments to fetch.
     */
    orderBy?: LoanPaymentOrderByWithRelationInput | LoanPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanPayments.
     */
    cursor?: LoanPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanPayments.
     */
    skip?: number
    distinct?: LoanPaymentScalarFieldEnum | LoanPaymentScalarFieldEnum[]
  }

  /**
   * LoanPayment create
   */
  export type LoanPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanPayment.
     */
    data: XOR<LoanPaymentCreateInput, LoanPaymentUncheckedCreateInput>
  }

  /**
   * LoanPayment createMany
   */
  export type LoanPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanPayments.
     */
    data: LoanPaymentCreateManyInput | LoanPaymentCreateManyInput[]
  }

  /**
   * LoanPayment createManyAndReturn
   */
  export type LoanPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many LoanPayments.
     */
    data: LoanPaymentCreateManyInput | LoanPaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanPayment update
   */
  export type LoanPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanPayment.
     */
    data: XOR<LoanPaymentUpdateInput, LoanPaymentUncheckedUpdateInput>
    /**
     * Choose, which LoanPayment to update.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment updateMany
   */
  export type LoanPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanPayments.
     */
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyInput>
    /**
     * Filter which LoanPayments to update
     */
    where?: LoanPaymentWhereInput
    /**
     * Limit how many LoanPayments to update.
     */
    limit?: number
  }

  /**
   * LoanPayment updateManyAndReturn
   */
  export type LoanPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * The data used to update LoanPayments.
     */
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyInput>
    /**
     * Filter which LoanPayments to update
     */
    where?: LoanPaymentWhereInput
    /**
     * Limit how many LoanPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanPayment upsert
   */
  export type LoanPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanPayment to update in case it exists.
     */
    where: LoanPaymentWhereUniqueInput
    /**
     * In case the LoanPayment found by the `where` argument doesn't exist, create a new LoanPayment with this data.
     */
    create: XOR<LoanPaymentCreateInput, LoanPaymentUncheckedCreateInput>
    /**
     * In case the LoanPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanPaymentUpdateInput, LoanPaymentUncheckedUpdateInput>
  }

  /**
   * LoanPayment delete
   */
  export type LoanPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
    /**
     * Filter which LoanPayment to delete.
     */
    where: LoanPaymentWhereUniqueInput
  }

  /**
   * LoanPayment deleteMany
   */
  export type LoanPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanPayments to delete
     */
    where?: LoanPaymentWhereInput
    /**
     * Limit how many LoanPayments to delete.
     */
    limit?: number
  }

  /**
   * LoanPayment without action
   */
  export type LoanPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanPayment
     */
    select?: LoanPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanPayment
     */
    omit?: LoanPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanPaymentInclude<ExtArgs> | null
  }


  /**
   * Model Deposits
   */

  export type AggregateDeposits = {
    _count: DepositsCountAggregateOutputType | null
    _avg: DepositsAvgAggregateOutputType | null
    _sum: DepositsSumAggregateOutputType | null
    _min: DepositsMinAggregateOutputType | null
    _max: DepositsMaxAggregateOutputType | null
  }

  export type DepositsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
    interest_rate: number | null
    term: number | null
    calculated_accrued_interest: number | null
    calculated_total_payout: number | null
    early_withdrawal_penalty_percent: number | null
  }

  export type DepositsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
    interest_rate: number | null
    term: number | null
    calculated_accrued_interest: number | null
    calculated_total_payout: number | null
    early_withdrawal_penalty_percent: number | null
  }

  export type DepositsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
    interest_rate: number | null
    term: number | null
    status: string | null
    created_at: Date | null
    approved_at: Date | null
    maturity_date: Date | null
    closed_at: Date | null
    calculated_accrued_interest: number | null
    calculated_total_payout: number | null
    early_withdrawal_requested_at: Date | null
    early_withdrawal_penalty_percent: number | null
  }

  export type DepositsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
    interest_rate: number | null
    term: number | null
    status: string | null
    created_at: Date | null
    approved_at: Date | null
    maturity_date: Date | null
    closed_at: Date | null
    calculated_accrued_interest: number | null
    calculated_total_payout: number | null
    early_withdrawal_requested_at: Date | null
    early_withdrawal_penalty_percent: number | null
  }

  export type DepositsCountAggregateOutputType = {
    id: number
    user_id: number
    amount: number
    interest_rate: number
    term: number
    status: number
    created_at: number
    approved_at: number
    maturity_date: number
    closed_at: number
    calculated_accrued_interest: number
    calculated_total_payout: number
    early_withdrawal_requested_at: number
    early_withdrawal_penalty_percent: number
    _all: number
  }


  export type DepositsAvgAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    interest_rate?: true
    term?: true
    calculated_accrued_interest?: true
    calculated_total_payout?: true
    early_withdrawal_penalty_percent?: true
  }

  export type DepositsSumAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    interest_rate?: true
    term?: true
    calculated_accrued_interest?: true
    calculated_total_payout?: true
    early_withdrawal_penalty_percent?: true
  }

  export type DepositsMinAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    interest_rate?: true
    term?: true
    status?: true
    created_at?: true
    approved_at?: true
    maturity_date?: true
    closed_at?: true
    calculated_accrued_interest?: true
    calculated_total_payout?: true
    early_withdrawal_requested_at?: true
    early_withdrawal_penalty_percent?: true
  }

  export type DepositsMaxAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    interest_rate?: true
    term?: true
    status?: true
    created_at?: true
    approved_at?: true
    maturity_date?: true
    closed_at?: true
    calculated_accrued_interest?: true
    calculated_total_payout?: true
    early_withdrawal_requested_at?: true
    early_withdrawal_penalty_percent?: true
  }

  export type DepositsCountAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    interest_rate?: true
    term?: true
    status?: true
    created_at?: true
    approved_at?: true
    maturity_date?: true
    closed_at?: true
    calculated_accrued_interest?: true
    calculated_total_payout?: true
    early_withdrawal_requested_at?: true
    early_withdrawal_penalty_percent?: true
    _all?: true
  }

  export type DepositsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposits to aggregate.
     */
    where?: DepositsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositsOrderByWithRelationInput | DepositsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepositsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deposits
    **/
    _count?: true | DepositsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositsMaxAggregateInputType
  }

  export type GetDepositsAggregateType<T extends DepositsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeposits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeposits[P]>
      : GetScalarType<T[P], AggregateDeposits[P]>
  }




  export type DepositsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositsWhereInput
    orderBy?: DepositsOrderByWithAggregationInput | DepositsOrderByWithAggregationInput[]
    by: DepositsScalarFieldEnum[] | DepositsScalarFieldEnum
    having?: DepositsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositsCountAggregateInputType | true
    _avg?: DepositsAvgAggregateInputType
    _sum?: DepositsSumAggregateInputType
    _min?: DepositsMinAggregateInputType
    _max?: DepositsMaxAggregateInputType
  }

  export type DepositsGroupByOutputType = {
    id: number
    user_id: number
    amount: number
    interest_rate: number
    term: number
    status: string
    created_at: Date
    approved_at: Date | null
    maturity_date: Date | null
    closed_at: Date | null
    calculated_accrued_interest: number | null
    calculated_total_payout: number | null
    early_withdrawal_requested_at: Date | null
    early_withdrawal_penalty_percent: number | null
    _count: DepositsCountAggregateOutputType | null
    _avg: DepositsAvgAggregateOutputType | null
    _sum: DepositsSumAggregateOutputType | null
    _min: DepositsMinAggregateOutputType | null
    _max: DepositsMaxAggregateOutputType | null
  }

  type GetDepositsGroupByPayload<T extends DepositsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepositsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositsGroupByOutputType[P]>
            : GetScalarType<T[P], DepositsGroupByOutputType[P]>
        }
      >
    >


  export type DepositsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    interest_rate?: boolean
    term?: boolean
    status?: boolean
    created_at?: boolean
    approved_at?: boolean
    maturity_date?: boolean
    closed_at?: boolean
    calculated_accrued_interest?: boolean
    calculated_total_payout?: boolean
    early_withdrawal_requested_at?: boolean
    early_withdrawal_penalty_percent?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposits"]>

  export type DepositsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    interest_rate?: boolean
    term?: boolean
    status?: boolean
    created_at?: boolean
    approved_at?: boolean
    maturity_date?: boolean
    closed_at?: boolean
    calculated_accrued_interest?: boolean
    calculated_total_payout?: boolean
    early_withdrawal_requested_at?: boolean
    early_withdrawal_penalty_percent?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposits"]>

  export type DepositsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    interest_rate?: boolean
    term?: boolean
    status?: boolean
    created_at?: boolean
    approved_at?: boolean
    maturity_date?: boolean
    closed_at?: boolean
    calculated_accrued_interest?: boolean
    calculated_total_payout?: boolean
    early_withdrawal_requested_at?: boolean
    early_withdrawal_penalty_percent?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deposits"]>

  export type DepositsSelectScalar = {
    id?: boolean
    user_id?: boolean
    amount?: boolean
    interest_rate?: boolean
    term?: boolean
    status?: boolean
    created_at?: boolean
    approved_at?: boolean
    maturity_date?: boolean
    closed_at?: boolean
    calculated_accrued_interest?: boolean
    calculated_total_payout?: boolean
    early_withdrawal_requested_at?: boolean
    early_withdrawal_penalty_percent?: boolean
  }

  export type DepositsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "amount" | "interest_rate" | "term" | "status" | "created_at" | "approved_at" | "maturity_date" | "closed_at" | "calculated_accrued_interest" | "calculated_total_payout" | "early_withdrawal_requested_at" | "early_withdrawal_penalty_percent", ExtArgs["result"]["deposits"]>
  export type DepositsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type DepositsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type DepositsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $DepositsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deposits"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      amount: number
      interest_rate: number
      term: number
      status: string
      created_at: Date
      approved_at: Date | null
      maturity_date: Date | null
      closed_at: Date | null
      calculated_accrued_interest: number | null
      calculated_total_payout: number | null
      early_withdrawal_requested_at: Date | null
      early_withdrawal_penalty_percent: number | null
    }, ExtArgs["result"]["deposits"]>
    composites: {}
  }

  type DepositsGetPayload<S extends boolean | null | undefined | DepositsDefaultArgs> = $Result.GetResult<Prisma.$DepositsPayload, S>

  type DepositsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepositsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepositsCountAggregateInputType | true
    }

  export interface DepositsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deposits'], meta: { name: 'Deposits' } }
    /**
     * Find zero or one Deposits that matches the filter.
     * @param {DepositsFindUniqueArgs} args - Arguments to find a Deposits
     * @example
     * // Get one Deposits
     * const deposits = await prisma.deposits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepositsFindUniqueArgs>(args: SelectSubset<T, DepositsFindUniqueArgs<ExtArgs>>): Prisma__DepositsClient<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deposits that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepositsFindUniqueOrThrowArgs} args - Arguments to find a Deposits
     * @example
     * // Get one Deposits
     * const deposits = await prisma.deposits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepositsFindUniqueOrThrowArgs>(args: SelectSubset<T, DepositsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepositsClient<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositsFindFirstArgs} args - Arguments to find a Deposits
     * @example
     * // Get one Deposits
     * const deposits = await prisma.deposits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepositsFindFirstArgs>(args?: SelectSubset<T, DepositsFindFirstArgs<ExtArgs>>): Prisma__DepositsClient<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deposits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositsFindFirstOrThrowArgs} args - Arguments to find a Deposits
     * @example
     * // Get one Deposits
     * const deposits = await prisma.deposits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepositsFindFirstOrThrowArgs>(args?: SelectSubset<T, DepositsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepositsClient<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deposits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deposits
     * const deposits = await prisma.deposits.findMany()
     * 
     * // Get first 10 Deposits
     * const deposits = await prisma.deposits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositsWithIdOnly = await prisma.deposits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepositsFindManyArgs>(args?: SelectSubset<T, DepositsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deposits.
     * @param {DepositsCreateArgs} args - Arguments to create a Deposits.
     * @example
     * // Create one Deposits
     * const Deposits = await prisma.deposits.create({
     *   data: {
     *     // ... data to create a Deposits
     *   }
     * })
     * 
     */
    create<T extends DepositsCreateArgs>(args: SelectSubset<T, DepositsCreateArgs<ExtArgs>>): Prisma__DepositsClient<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deposits.
     * @param {DepositsCreateManyArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposits = await prisma.deposits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepositsCreateManyArgs>(args?: SelectSubset<T, DepositsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deposits and returns the data saved in the database.
     * @param {DepositsCreateManyAndReturnArgs} args - Arguments to create many Deposits.
     * @example
     * // Create many Deposits
     * const deposits = await prisma.deposits.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deposits and only return the `id`
     * const depositsWithIdOnly = await prisma.deposits.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepositsCreateManyAndReturnArgs>(args?: SelectSubset<T, DepositsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deposits.
     * @param {DepositsDeleteArgs} args - Arguments to delete one Deposits.
     * @example
     * // Delete one Deposits
     * const Deposits = await prisma.deposits.delete({
     *   where: {
     *     // ... filter to delete one Deposits
     *   }
     * })
     * 
     */
    delete<T extends DepositsDeleteArgs>(args: SelectSubset<T, DepositsDeleteArgs<ExtArgs>>): Prisma__DepositsClient<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deposits.
     * @param {DepositsUpdateArgs} args - Arguments to update one Deposits.
     * @example
     * // Update one Deposits
     * const deposits = await prisma.deposits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepositsUpdateArgs>(args: SelectSubset<T, DepositsUpdateArgs<ExtArgs>>): Prisma__DepositsClient<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deposits.
     * @param {DepositsDeleteManyArgs} args - Arguments to filter Deposits to delete.
     * @example
     * // Delete a few Deposits
     * const { count } = await prisma.deposits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepositsDeleteManyArgs>(args?: SelectSubset<T, DepositsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deposits
     * const deposits = await prisma.deposits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepositsUpdateManyArgs>(args: SelectSubset<T, DepositsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deposits and returns the data updated in the database.
     * @param {DepositsUpdateManyAndReturnArgs} args - Arguments to update many Deposits.
     * @example
     * // Update many Deposits
     * const deposits = await prisma.deposits.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deposits and only return the `id`
     * const depositsWithIdOnly = await prisma.deposits.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepositsUpdateManyAndReturnArgs>(args: SelectSubset<T, DepositsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deposits.
     * @param {DepositsUpsertArgs} args - Arguments to update or create a Deposits.
     * @example
     * // Update or create a Deposits
     * const deposits = await prisma.deposits.upsert({
     *   create: {
     *     // ... data to create a Deposits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deposits we want to update
     *   }
     * })
     */
    upsert<T extends DepositsUpsertArgs>(args: SelectSubset<T, DepositsUpsertArgs<ExtArgs>>): Prisma__DepositsClient<$Result.GetResult<Prisma.$DepositsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositsCountArgs} args - Arguments to filter Deposits to count.
     * @example
     * // Count the number of Deposits
     * const count = await prisma.deposits.count({
     *   where: {
     *     // ... the filter for the Deposits we want to count
     *   }
     * })
    **/
    count<T extends DepositsCountArgs>(
      args?: Subset<T, DepositsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositsAggregateArgs>(args: Subset<T, DepositsAggregateArgs>): Prisma.PrismaPromise<GetDepositsAggregateType<T>>

    /**
     * Group by Deposits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepositsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepositsGroupByArgs['orderBy'] }
        : { orderBy?: DepositsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepositsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deposits model
   */
  readonly fields: DepositsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deposits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepositsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deposits model
   */
  interface DepositsFieldRefs {
    readonly id: FieldRef<"Deposits", 'Int'>
    readonly user_id: FieldRef<"Deposits", 'Int'>
    readonly amount: FieldRef<"Deposits", 'Float'>
    readonly interest_rate: FieldRef<"Deposits", 'Float'>
    readonly term: FieldRef<"Deposits", 'Int'>
    readonly status: FieldRef<"Deposits", 'String'>
    readonly created_at: FieldRef<"Deposits", 'DateTime'>
    readonly approved_at: FieldRef<"Deposits", 'DateTime'>
    readonly maturity_date: FieldRef<"Deposits", 'DateTime'>
    readonly closed_at: FieldRef<"Deposits", 'DateTime'>
    readonly calculated_accrued_interest: FieldRef<"Deposits", 'Float'>
    readonly calculated_total_payout: FieldRef<"Deposits", 'Float'>
    readonly early_withdrawal_requested_at: FieldRef<"Deposits", 'DateTime'>
    readonly early_withdrawal_penalty_percent: FieldRef<"Deposits", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Deposits findUnique
   */
  export type DepositsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
    /**
     * Filter, which Deposits to fetch.
     */
    where: DepositsWhereUniqueInput
  }

  /**
   * Deposits findUniqueOrThrow
   */
  export type DepositsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
    /**
     * Filter, which Deposits to fetch.
     */
    where: DepositsWhereUniqueInput
  }

  /**
   * Deposits findFirst
   */
  export type DepositsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
    /**
     * Filter, which Deposits to fetch.
     */
    where?: DepositsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositsOrderByWithRelationInput | DepositsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deposits.
     */
    cursor?: DepositsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deposits.
     */
    distinct?: DepositsScalarFieldEnum | DepositsScalarFieldEnum[]
  }

  /**
   * Deposits findFirstOrThrow
   */
  export type DepositsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
    /**
     * Filter, which Deposits to fetch.
     */
    where?: DepositsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositsOrderByWithRelationInput | DepositsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deposits.
     */
    cursor?: DepositsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deposits.
     */
    distinct?: DepositsScalarFieldEnum | DepositsScalarFieldEnum[]
  }

  /**
   * Deposits findMany
   */
  export type DepositsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
    /**
     * Filter, which Deposits to fetch.
     */
    where?: DepositsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deposits to fetch.
     */
    orderBy?: DepositsOrderByWithRelationInput | DepositsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deposits.
     */
    cursor?: DepositsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deposits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deposits.
     */
    skip?: number
    distinct?: DepositsScalarFieldEnum | DepositsScalarFieldEnum[]
  }

  /**
   * Deposits create
   */
  export type DepositsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
    /**
     * The data needed to create a Deposits.
     */
    data: XOR<DepositsCreateInput, DepositsUncheckedCreateInput>
  }

  /**
   * Deposits createMany
   */
  export type DepositsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deposits.
     */
    data: DepositsCreateManyInput | DepositsCreateManyInput[]
  }

  /**
   * Deposits createManyAndReturn
   */
  export type DepositsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * The data used to create many Deposits.
     */
    data: DepositsCreateManyInput | DepositsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deposits update
   */
  export type DepositsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
    /**
     * The data needed to update a Deposits.
     */
    data: XOR<DepositsUpdateInput, DepositsUncheckedUpdateInput>
    /**
     * Choose, which Deposits to update.
     */
    where: DepositsWhereUniqueInput
  }

  /**
   * Deposits updateMany
   */
  export type DepositsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deposits.
     */
    data: XOR<DepositsUpdateManyMutationInput, DepositsUncheckedUpdateManyInput>
    /**
     * Filter which Deposits to update
     */
    where?: DepositsWhereInput
    /**
     * Limit how many Deposits to update.
     */
    limit?: number
  }

  /**
   * Deposits updateManyAndReturn
   */
  export type DepositsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * The data used to update Deposits.
     */
    data: XOR<DepositsUpdateManyMutationInput, DepositsUncheckedUpdateManyInput>
    /**
     * Filter which Deposits to update
     */
    where?: DepositsWhereInput
    /**
     * Limit how many Deposits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deposits upsert
   */
  export type DepositsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
    /**
     * The filter to search for the Deposits to update in case it exists.
     */
    where: DepositsWhereUniqueInput
    /**
     * In case the Deposits found by the `where` argument doesn't exist, create a new Deposits with this data.
     */
    create: XOR<DepositsCreateInput, DepositsUncheckedCreateInput>
    /**
     * In case the Deposits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepositsUpdateInput, DepositsUncheckedUpdateInput>
  }

  /**
   * Deposits delete
   */
  export type DepositsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
    /**
     * Filter which Deposits to delete.
     */
    where: DepositsWhereUniqueInput
  }

  /**
   * Deposits deleteMany
   */
  export type DepositsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deposits to delete
     */
    where?: DepositsWhereInput
    /**
     * Limit how many Deposits to delete.
     */
    limit?: number
  }

  /**
   * Deposits without action
   */
  export type DepositsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deposits
     */
    select?: DepositsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deposits
     */
    omit?: DepositsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositsInclude<ExtArgs> | null
  }


  /**
   * Model Cards
   */

  export type AggregateCards = {
    _count: CardsCountAggregateOutputType | null
    _avg: CardsAvgAggregateOutputType | null
    _sum: CardsSumAggregateOutputType | null
    _min: CardsMinAggregateOutputType | null
    _max: CardsMaxAggregateOutputType | null
  }

  export type CardsAvgAggregateOutputType = {
    id: number | null
    cvv: number | null
    holder_id: number | null
    pin: number | null
    balance: number | null
  }

  export type CardsSumAggregateOutputType = {
    id: number | null
    cvv: number | null
    holder_id: number | null
    pin: number | null
    balance: number | null
  }

  export type CardsMinAggregateOutputType = {
    id: number | null
    card_number: string | null
    cvv: number | null
    holder_id: number | null
    pin: number | null
    balance: number | null
    dueDate: string | null
    status: string | null
  }

  export type CardsMaxAggregateOutputType = {
    id: number | null
    card_number: string | null
    cvv: number | null
    holder_id: number | null
    pin: number | null
    balance: number | null
    dueDate: string | null
    status: string | null
  }

  export type CardsCountAggregateOutputType = {
    id: number
    card_number: number
    cvv: number
    holder_id: number
    pin: number
    balance: number
    dueDate: number
    status: number
    _all: number
  }


  export type CardsAvgAggregateInputType = {
    id?: true
    cvv?: true
    holder_id?: true
    pin?: true
    balance?: true
  }

  export type CardsSumAggregateInputType = {
    id?: true
    cvv?: true
    holder_id?: true
    pin?: true
    balance?: true
  }

  export type CardsMinAggregateInputType = {
    id?: true
    card_number?: true
    cvv?: true
    holder_id?: true
    pin?: true
    balance?: true
    dueDate?: true
    status?: true
  }

  export type CardsMaxAggregateInputType = {
    id?: true
    card_number?: true
    cvv?: true
    holder_id?: true
    pin?: true
    balance?: true
    dueDate?: true
    status?: true
  }

  export type CardsCountAggregateInputType = {
    id?: true
    card_number?: true
    cvv?: true
    holder_id?: true
    pin?: true
    balance?: true
    dueDate?: true
    status?: true
    _all?: true
  }

  export type CardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cards to aggregate.
     */
    where?: CardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardsOrderByWithRelationInput | CardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cards
    **/
    _count?: true | CardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardsMaxAggregateInputType
  }

  export type GetCardsAggregateType<T extends CardsAggregateArgs> = {
        [P in keyof T & keyof AggregateCards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCards[P]>
      : GetScalarType<T[P], AggregateCards[P]>
  }




  export type CardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardsWhereInput
    orderBy?: CardsOrderByWithAggregationInput | CardsOrderByWithAggregationInput[]
    by: CardsScalarFieldEnum[] | CardsScalarFieldEnum
    having?: CardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardsCountAggregateInputType | true
    _avg?: CardsAvgAggregateInputType
    _sum?: CardsSumAggregateInputType
    _min?: CardsMinAggregateInputType
    _max?: CardsMaxAggregateInputType
  }

  export type CardsGroupByOutputType = {
    id: number
    card_number: string
    cvv: number
    holder_id: number
    pin: number
    balance: number
    dueDate: string
    status: string
    _count: CardsCountAggregateOutputType | null
    _avg: CardsAvgAggregateOutputType | null
    _sum: CardsSumAggregateOutputType | null
    _min: CardsMinAggregateOutputType | null
    _max: CardsMaxAggregateOutputType | null
  }

  type GetCardsGroupByPayload<T extends CardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardsGroupByOutputType[P]>
            : GetScalarType<T[P], CardsGroupByOutputType[P]>
        }
      >
    >


  export type CardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    card_number?: boolean
    cvv?: boolean
    holder_id?: boolean
    pin?: boolean
    balance?: boolean
    dueDate?: boolean
    status?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    SentTransactions?: boolean | Cards$SentTransactionsArgs<ExtArgs>
    ReceivedTransactions?: boolean | Cards$ReceivedTransactionsArgs<ExtArgs>
    _count?: boolean | CardsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cards"]>

  export type CardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    card_number?: boolean
    cvv?: boolean
    holder_id?: boolean
    pin?: boolean
    balance?: boolean
    dueDate?: boolean
    status?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cards"]>

  export type CardsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    card_number?: boolean
    cvv?: boolean
    holder_id?: boolean
    pin?: boolean
    balance?: boolean
    dueDate?: boolean
    status?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cards"]>

  export type CardsSelectScalar = {
    id?: boolean
    card_number?: boolean
    cvv?: boolean
    holder_id?: boolean
    pin?: boolean
    balance?: boolean
    dueDate?: boolean
    status?: boolean
  }

  export type CardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "card_number" | "cvv" | "holder_id" | "pin" | "balance" | "dueDate" | "status", ExtArgs["result"]["cards"]>
  export type CardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    SentTransactions?: boolean | Cards$SentTransactionsArgs<ExtArgs>
    ReceivedTransactions?: boolean | Cards$ReceivedTransactionsArgs<ExtArgs>
    _count?: boolean | CardsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type CardsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $CardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cards"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
      SentTransactions: Prisma.$CardTransactionPayload<ExtArgs>[]
      ReceivedTransactions: Prisma.$CardTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      card_number: string
      cvv: number
      holder_id: number
      pin: number
      balance: number
      dueDate: string
      status: string
    }, ExtArgs["result"]["cards"]>
    composites: {}
  }

  type CardsGetPayload<S extends boolean | null | undefined | CardsDefaultArgs> = $Result.GetResult<Prisma.$CardsPayload, S>

  type CardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardsCountAggregateInputType | true
    }

  export interface CardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cards'], meta: { name: 'Cards' } }
    /**
     * Find zero or one Cards that matches the filter.
     * @param {CardsFindUniqueArgs} args - Arguments to find a Cards
     * @example
     * // Get one Cards
     * const cards = await prisma.cards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardsFindUniqueArgs>(args: SelectSubset<T, CardsFindUniqueArgs<ExtArgs>>): Prisma__CardsClient<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardsFindUniqueOrThrowArgs} args - Arguments to find a Cards
     * @example
     * // Get one Cards
     * const cards = await prisma.cards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardsFindUniqueOrThrowArgs>(args: SelectSubset<T, CardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardsClient<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardsFindFirstArgs} args - Arguments to find a Cards
     * @example
     * // Get one Cards
     * const cards = await prisma.cards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardsFindFirstArgs>(args?: SelectSubset<T, CardsFindFirstArgs<ExtArgs>>): Prisma__CardsClient<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardsFindFirstOrThrowArgs} args - Arguments to find a Cards
     * @example
     * // Get one Cards
     * const cards = await prisma.cards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardsFindFirstOrThrowArgs>(args?: SelectSubset<T, CardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardsClient<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.cards.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.cards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardsWithIdOnly = await prisma.cards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardsFindManyArgs>(args?: SelectSubset<T, CardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cards.
     * @param {CardsCreateArgs} args - Arguments to create a Cards.
     * @example
     * // Create one Cards
     * const Cards = await prisma.cards.create({
     *   data: {
     *     // ... data to create a Cards
     *   }
     * })
     * 
     */
    create<T extends CardsCreateArgs>(args: SelectSubset<T, CardsCreateArgs<ExtArgs>>): Prisma__CardsClient<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cards.
     * @param {CardsCreateManyArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const cards = await prisma.cards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardsCreateManyArgs>(args?: SelectSubset<T, CardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cards and returns the data saved in the database.
     * @param {CardsCreateManyAndReturnArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const cards = await prisma.cards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cards and only return the `id`
     * const cardsWithIdOnly = await prisma.cards.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardsCreateManyAndReturnArgs>(args?: SelectSubset<T, CardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cards.
     * @param {CardsDeleteArgs} args - Arguments to delete one Cards.
     * @example
     * // Delete one Cards
     * const Cards = await prisma.cards.delete({
     *   where: {
     *     // ... filter to delete one Cards
     *   }
     * })
     * 
     */
    delete<T extends CardsDeleteArgs>(args: SelectSubset<T, CardsDeleteArgs<ExtArgs>>): Prisma__CardsClient<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cards.
     * @param {CardsUpdateArgs} args - Arguments to update one Cards.
     * @example
     * // Update one Cards
     * const cards = await prisma.cards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardsUpdateArgs>(args: SelectSubset<T, CardsUpdateArgs<ExtArgs>>): Prisma__CardsClient<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cards.
     * @param {CardsDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.cards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardsDeleteManyArgs>(args?: SelectSubset<T, CardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const cards = await prisma.cards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardsUpdateManyArgs>(args: SelectSubset<T, CardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards and returns the data updated in the database.
     * @param {CardsUpdateManyAndReturnArgs} args - Arguments to update many Cards.
     * @example
     * // Update many Cards
     * const cards = await prisma.cards.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cards and only return the `id`
     * const cardsWithIdOnly = await prisma.cards.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CardsUpdateManyAndReturnArgs>(args: SelectSubset<T, CardsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cards.
     * @param {CardsUpsertArgs} args - Arguments to update or create a Cards.
     * @example
     * // Update or create a Cards
     * const cards = await prisma.cards.upsert({
     *   create: {
     *     // ... data to create a Cards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cards we want to update
     *   }
     * })
     */
    upsert<T extends CardsUpsertArgs>(args: SelectSubset<T, CardsUpsertArgs<ExtArgs>>): Prisma__CardsClient<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardsCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.cards.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends CardsCountArgs>(
      args?: Subset<T, CardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardsAggregateArgs>(args: Subset<T, CardsAggregateArgs>): Prisma.PrismaPromise<GetCardsAggregateType<T>>

    /**
     * Group by Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardsGroupByArgs['orderBy'] }
        : { orderBy?: CardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cards model
   */
  readonly fields: CardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SentTransactions<T extends Cards$SentTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Cards$SentTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ReceivedTransactions<T extends Cards$ReceivedTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Cards$ReceivedTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cards model
   */
  interface CardsFieldRefs {
    readonly id: FieldRef<"Cards", 'Int'>
    readonly card_number: FieldRef<"Cards", 'String'>
    readonly cvv: FieldRef<"Cards", 'Int'>
    readonly holder_id: FieldRef<"Cards", 'Int'>
    readonly pin: FieldRef<"Cards", 'Int'>
    readonly balance: FieldRef<"Cards", 'Float'>
    readonly dueDate: FieldRef<"Cards", 'String'>
    readonly status: FieldRef<"Cards", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cards findUnique
   */
  export type CardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where: CardsWhereUniqueInput
  }

  /**
   * Cards findUniqueOrThrow
   */
  export type CardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where: CardsWhereUniqueInput
  }

  /**
   * Cards findFirst
   */
  export type CardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where?: CardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardsOrderByWithRelationInput | CardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardsScalarFieldEnum | CardsScalarFieldEnum[]
  }

  /**
   * Cards findFirstOrThrow
   */
  export type CardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where?: CardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardsOrderByWithRelationInput | CardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardsScalarFieldEnum | CardsScalarFieldEnum[]
  }

  /**
   * Cards findMany
   */
  export type CardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where?: CardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardsOrderByWithRelationInput | CardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cards.
     */
    cursor?: CardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    distinct?: CardsScalarFieldEnum | CardsScalarFieldEnum[]
  }

  /**
   * Cards create
   */
  export type CardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
    /**
     * The data needed to create a Cards.
     */
    data: XOR<CardsCreateInput, CardsUncheckedCreateInput>
  }

  /**
   * Cards createMany
   */
  export type CardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cards.
     */
    data: CardsCreateManyInput | CardsCreateManyInput[]
  }

  /**
   * Cards createManyAndReturn
   */
  export type CardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * The data used to create many Cards.
     */
    data: CardsCreateManyInput | CardsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cards update
   */
  export type CardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
    /**
     * The data needed to update a Cards.
     */
    data: XOR<CardsUpdateInput, CardsUncheckedUpdateInput>
    /**
     * Choose, which Cards to update.
     */
    where: CardsWhereUniqueInput
  }

  /**
   * Cards updateMany
   */
  export type CardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cards.
     */
    data: XOR<CardsUpdateManyMutationInput, CardsUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardsWhereInput
    /**
     * Limit how many Cards to update.
     */
    limit?: number
  }

  /**
   * Cards updateManyAndReturn
   */
  export type CardsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * The data used to update Cards.
     */
    data: XOR<CardsUpdateManyMutationInput, CardsUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardsWhereInput
    /**
     * Limit how many Cards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cards upsert
   */
  export type CardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
    /**
     * The filter to search for the Cards to update in case it exists.
     */
    where: CardsWhereUniqueInput
    /**
     * In case the Cards found by the `where` argument doesn't exist, create a new Cards with this data.
     */
    create: XOR<CardsCreateInput, CardsUncheckedCreateInput>
    /**
     * In case the Cards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardsUpdateInput, CardsUncheckedUpdateInput>
  }

  /**
   * Cards delete
   */
  export type CardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
    /**
     * Filter which Cards to delete.
     */
    where: CardsWhereUniqueInput
  }

  /**
   * Cards deleteMany
   */
  export type CardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cards to delete
     */
    where?: CardsWhereInput
    /**
     * Limit how many Cards to delete.
     */
    limit?: number
  }

  /**
   * Cards.SentTransactions
   */
  export type Cards$SentTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    where?: CardTransactionWhereInput
    orderBy?: CardTransactionOrderByWithRelationInput | CardTransactionOrderByWithRelationInput[]
    cursor?: CardTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardTransactionScalarFieldEnum | CardTransactionScalarFieldEnum[]
  }

  /**
   * Cards.ReceivedTransactions
   */
  export type Cards$ReceivedTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    where?: CardTransactionWhereInput
    orderBy?: CardTransactionOrderByWithRelationInput | CardTransactionOrderByWithRelationInput[]
    cursor?: CardTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardTransactionScalarFieldEnum | CardTransactionScalarFieldEnum[]
  }

  /**
   * Cards without action
   */
  export type CardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cards
     */
    select?: CardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cards
     */
    omit?: CardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardsInclude<ExtArgs> | null
  }


  /**
   * Model CardTransaction
   */

  export type AggregateCardTransaction = {
    _count: CardTransactionCountAggregateOutputType | null
    _avg: CardTransactionAvgAggregateOutputType | null
    _sum: CardTransactionSumAggregateOutputType | null
    _min: CardTransactionMinAggregateOutputType | null
    _max: CardTransactionMaxAggregateOutputType | null
  }

  export type CardTransactionAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    senderCardId: number | null
    receiverCardId: number | null
  }

  export type CardTransactionSumAggregateOutputType = {
    id: number | null
    amount: number | null
    senderCardId: number | null
    receiverCardId: number | null
  }

  export type CardTransactionMinAggregateOutputType = {
    id: number | null
    amount: number | null
    timestamp: Date | null
    description: string | null
    senderCardId: number | null
    receiverCardId: number | null
  }

  export type CardTransactionMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    timestamp: Date | null
    description: string | null
    senderCardId: number | null
    receiverCardId: number | null
  }

  export type CardTransactionCountAggregateOutputType = {
    id: number
    amount: number
    timestamp: number
    description: number
    senderCardId: number
    receiverCardId: number
    _all: number
  }


  export type CardTransactionAvgAggregateInputType = {
    id?: true
    amount?: true
    senderCardId?: true
    receiverCardId?: true
  }

  export type CardTransactionSumAggregateInputType = {
    id?: true
    amount?: true
    senderCardId?: true
    receiverCardId?: true
  }

  export type CardTransactionMinAggregateInputType = {
    id?: true
    amount?: true
    timestamp?: true
    description?: true
    senderCardId?: true
    receiverCardId?: true
  }

  export type CardTransactionMaxAggregateInputType = {
    id?: true
    amount?: true
    timestamp?: true
    description?: true
    senderCardId?: true
    receiverCardId?: true
  }

  export type CardTransactionCountAggregateInputType = {
    id?: true
    amount?: true
    timestamp?: true
    description?: true
    senderCardId?: true
    receiverCardId?: true
    _all?: true
  }

  export type CardTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardTransaction to aggregate.
     */
    where?: CardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardTransactions to fetch.
     */
    orderBy?: CardTransactionOrderByWithRelationInput | CardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardTransactions
    **/
    _count?: true | CardTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardTransactionMaxAggregateInputType
  }

  export type GetCardTransactionAggregateType<T extends CardTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCardTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardTransaction[P]>
      : GetScalarType<T[P], AggregateCardTransaction[P]>
  }




  export type CardTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardTransactionWhereInput
    orderBy?: CardTransactionOrderByWithAggregationInput | CardTransactionOrderByWithAggregationInput[]
    by: CardTransactionScalarFieldEnum[] | CardTransactionScalarFieldEnum
    having?: CardTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardTransactionCountAggregateInputType | true
    _avg?: CardTransactionAvgAggregateInputType
    _sum?: CardTransactionSumAggregateInputType
    _min?: CardTransactionMinAggregateInputType
    _max?: CardTransactionMaxAggregateInputType
  }

  export type CardTransactionGroupByOutputType = {
    id: number
    amount: number
    timestamp: Date
    description: string
    senderCardId: number
    receiverCardId: number
    _count: CardTransactionCountAggregateOutputType | null
    _avg: CardTransactionAvgAggregateOutputType | null
    _sum: CardTransactionSumAggregateOutputType | null
    _min: CardTransactionMinAggregateOutputType | null
    _max: CardTransactionMaxAggregateOutputType | null
  }

  type GetCardTransactionGroupByPayload<T extends CardTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CardTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CardTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    timestamp?: boolean
    description?: boolean
    senderCardId?: boolean
    receiverCardId?: boolean
    SenderCard?: boolean | CardsDefaultArgs<ExtArgs>
    ReceiverCard?: boolean | CardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardTransaction"]>

  export type CardTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    timestamp?: boolean
    description?: boolean
    senderCardId?: boolean
    receiverCardId?: boolean
    SenderCard?: boolean | CardsDefaultArgs<ExtArgs>
    ReceiverCard?: boolean | CardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardTransaction"]>

  export type CardTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    timestamp?: boolean
    description?: boolean
    senderCardId?: boolean
    receiverCardId?: boolean
    SenderCard?: boolean | CardsDefaultArgs<ExtArgs>
    ReceiverCard?: boolean | CardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cardTransaction"]>

  export type CardTransactionSelectScalar = {
    id?: boolean
    amount?: boolean
    timestamp?: boolean
    description?: boolean
    senderCardId?: boolean
    receiverCardId?: boolean
  }

  export type CardTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "timestamp" | "description" | "senderCardId" | "receiverCardId", ExtArgs["result"]["cardTransaction"]>
  export type CardTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SenderCard?: boolean | CardsDefaultArgs<ExtArgs>
    ReceiverCard?: boolean | CardsDefaultArgs<ExtArgs>
  }
  export type CardTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SenderCard?: boolean | CardsDefaultArgs<ExtArgs>
    ReceiverCard?: boolean | CardsDefaultArgs<ExtArgs>
  }
  export type CardTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SenderCard?: boolean | CardsDefaultArgs<ExtArgs>
    ReceiverCard?: boolean | CardsDefaultArgs<ExtArgs>
  }

  export type $CardTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardTransaction"
    objects: {
      SenderCard: Prisma.$CardsPayload<ExtArgs>
      ReceiverCard: Prisma.$CardsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      timestamp: Date
      description: string
      senderCardId: number
      receiverCardId: number
    }, ExtArgs["result"]["cardTransaction"]>
    composites: {}
  }

  type CardTransactionGetPayload<S extends boolean | null | undefined | CardTransactionDefaultArgs> = $Result.GetResult<Prisma.$CardTransactionPayload, S>

  type CardTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardTransactionCountAggregateInputType | true
    }

  export interface CardTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardTransaction'], meta: { name: 'CardTransaction' } }
    /**
     * Find zero or one CardTransaction that matches the filter.
     * @param {CardTransactionFindUniqueArgs} args - Arguments to find a CardTransaction
     * @example
     * // Get one CardTransaction
     * const cardTransaction = await prisma.cardTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardTransactionFindUniqueArgs>(args: SelectSubset<T, CardTransactionFindUniqueArgs<ExtArgs>>): Prisma__CardTransactionClient<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardTransactionFindUniqueOrThrowArgs} args - Arguments to find a CardTransaction
     * @example
     * // Get one CardTransaction
     * const cardTransaction = await prisma.cardTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CardTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardTransactionClient<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardTransactionFindFirstArgs} args - Arguments to find a CardTransaction
     * @example
     * // Get one CardTransaction
     * const cardTransaction = await prisma.cardTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardTransactionFindFirstArgs>(args?: SelectSubset<T, CardTransactionFindFirstArgs<ExtArgs>>): Prisma__CardTransactionClient<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardTransactionFindFirstOrThrowArgs} args - Arguments to find a CardTransaction
     * @example
     * // Get one CardTransaction
     * const cardTransaction = await prisma.cardTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CardTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardTransactionClient<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardTransactions
     * const cardTransactions = await prisma.cardTransaction.findMany()
     * 
     * // Get first 10 CardTransactions
     * const cardTransactions = await prisma.cardTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardTransactionWithIdOnly = await prisma.cardTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardTransactionFindManyArgs>(args?: SelectSubset<T, CardTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardTransaction.
     * @param {CardTransactionCreateArgs} args - Arguments to create a CardTransaction.
     * @example
     * // Create one CardTransaction
     * const CardTransaction = await prisma.cardTransaction.create({
     *   data: {
     *     // ... data to create a CardTransaction
     *   }
     * })
     * 
     */
    create<T extends CardTransactionCreateArgs>(args: SelectSubset<T, CardTransactionCreateArgs<ExtArgs>>): Prisma__CardTransactionClient<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardTransactions.
     * @param {CardTransactionCreateManyArgs} args - Arguments to create many CardTransactions.
     * @example
     * // Create many CardTransactions
     * const cardTransaction = await prisma.cardTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardTransactionCreateManyArgs>(args?: SelectSubset<T, CardTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CardTransactions and returns the data saved in the database.
     * @param {CardTransactionCreateManyAndReturnArgs} args - Arguments to create many CardTransactions.
     * @example
     * // Create many CardTransactions
     * const cardTransaction = await prisma.cardTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CardTransactions and only return the `id`
     * const cardTransactionWithIdOnly = await prisma.cardTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CardTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CardTransaction.
     * @param {CardTransactionDeleteArgs} args - Arguments to delete one CardTransaction.
     * @example
     * // Delete one CardTransaction
     * const CardTransaction = await prisma.cardTransaction.delete({
     *   where: {
     *     // ... filter to delete one CardTransaction
     *   }
     * })
     * 
     */
    delete<T extends CardTransactionDeleteArgs>(args: SelectSubset<T, CardTransactionDeleteArgs<ExtArgs>>): Prisma__CardTransactionClient<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardTransaction.
     * @param {CardTransactionUpdateArgs} args - Arguments to update one CardTransaction.
     * @example
     * // Update one CardTransaction
     * const cardTransaction = await prisma.cardTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardTransactionUpdateArgs>(args: SelectSubset<T, CardTransactionUpdateArgs<ExtArgs>>): Prisma__CardTransactionClient<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardTransactions.
     * @param {CardTransactionDeleteManyArgs} args - Arguments to filter CardTransactions to delete.
     * @example
     * // Delete a few CardTransactions
     * const { count } = await prisma.cardTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardTransactionDeleteManyArgs>(args?: SelectSubset<T, CardTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardTransactions
     * const cardTransaction = await prisma.cardTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardTransactionUpdateManyArgs>(args: SelectSubset<T, CardTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardTransactions and returns the data updated in the database.
     * @param {CardTransactionUpdateManyAndReturnArgs} args - Arguments to update many CardTransactions.
     * @example
     * // Update many CardTransactions
     * const cardTransaction = await prisma.cardTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CardTransactions and only return the `id`
     * const cardTransactionWithIdOnly = await prisma.cardTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CardTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, CardTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CardTransaction.
     * @param {CardTransactionUpsertArgs} args - Arguments to update or create a CardTransaction.
     * @example
     * // Update or create a CardTransaction
     * const cardTransaction = await prisma.cardTransaction.upsert({
     *   create: {
     *     // ... data to create a CardTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CardTransactionUpsertArgs>(args: SelectSubset<T, CardTransactionUpsertArgs<ExtArgs>>): Prisma__CardTransactionClient<$Result.GetResult<Prisma.$CardTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardTransactionCountArgs} args - Arguments to filter CardTransactions to count.
     * @example
     * // Count the number of CardTransactions
     * const count = await prisma.cardTransaction.count({
     *   where: {
     *     // ... the filter for the CardTransactions we want to count
     *   }
     * })
    **/
    count<T extends CardTransactionCountArgs>(
      args?: Subset<T, CardTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardTransactionAggregateArgs>(args: Subset<T, CardTransactionAggregateArgs>): Prisma.PrismaPromise<GetCardTransactionAggregateType<T>>

    /**
     * Group by CardTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CardTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardTransaction model
   */
  readonly fields: CardTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SenderCard<T extends CardsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardsDefaultArgs<ExtArgs>>): Prisma__CardsClient<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ReceiverCard<T extends CardsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardsDefaultArgs<ExtArgs>>): Prisma__CardsClient<$Result.GetResult<Prisma.$CardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardTransaction model
   */
  interface CardTransactionFieldRefs {
    readonly id: FieldRef<"CardTransaction", 'Int'>
    readonly amount: FieldRef<"CardTransaction", 'Float'>
    readonly timestamp: FieldRef<"CardTransaction", 'DateTime'>
    readonly description: FieldRef<"CardTransaction", 'String'>
    readonly senderCardId: FieldRef<"CardTransaction", 'Int'>
    readonly receiverCardId: FieldRef<"CardTransaction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CardTransaction findUnique
   */
  export type CardTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CardTransaction to fetch.
     */
    where: CardTransactionWhereUniqueInput
  }

  /**
   * CardTransaction findUniqueOrThrow
   */
  export type CardTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CardTransaction to fetch.
     */
    where: CardTransactionWhereUniqueInput
  }

  /**
   * CardTransaction findFirst
   */
  export type CardTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CardTransaction to fetch.
     */
    where?: CardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardTransactions to fetch.
     */
    orderBy?: CardTransactionOrderByWithRelationInput | CardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardTransactions.
     */
    cursor?: CardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardTransactions.
     */
    distinct?: CardTransactionScalarFieldEnum | CardTransactionScalarFieldEnum[]
  }

  /**
   * CardTransaction findFirstOrThrow
   */
  export type CardTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CardTransaction to fetch.
     */
    where?: CardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardTransactions to fetch.
     */
    orderBy?: CardTransactionOrderByWithRelationInput | CardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardTransactions.
     */
    cursor?: CardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardTransactions.
     */
    distinct?: CardTransactionScalarFieldEnum | CardTransactionScalarFieldEnum[]
  }

  /**
   * CardTransaction findMany
   */
  export type CardTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CardTransactions to fetch.
     */
    where?: CardTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardTransactions to fetch.
     */
    orderBy?: CardTransactionOrderByWithRelationInput | CardTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardTransactions.
     */
    cursor?: CardTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardTransactions.
     */
    skip?: number
    distinct?: CardTransactionScalarFieldEnum | CardTransactionScalarFieldEnum[]
  }

  /**
   * CardTransaction create
   */
  export type CardTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CardTransaction.
     */
    data: XOR<CardTransactionCreateInput, CardTransactionUncheckedCreateInput>
  }

  /**
   * CardTransaction createMany
   */
  export type CardTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardTransactions.
     */
    data: CardTransactionCreateManyInput | CardTransactionCreateManyInput[]
  }

  /**
   * CardTransaction createManyAndReturn
   */
  export type CardTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many CardTransactions.
     */
    data: CardTransactionCreateManyInput | CardTransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardTransaction update
   */
  export type CardTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CardTransaction.
     */
    data: XOR<CardTransactionUpdateInput, CardTransactionUncheckedUpdateInput>
    /**
     * Choose, which CardTransaction to update.
     */
    where: CardTransactionWhereUniqueInput
  }

  /**
   * CardTransaction updateMany
   */
  export type CardTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardTransactions.
     */
    data: XOR<CardTransactionUpdateManyMutationInput, CardTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CardTransactions to update
     */
    where?: CardTransactionWhereInput
    /**
     * Limit how many CardTransactions to update.
     */
    limit?: number
  }

  /**
   * CardTransaction updateManyAndReturn
   */
  export type CardTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * The data used to update CardTransactions.
     */
    data: XOR<CardTransactionUpdateManyMutationInput, CardTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CardTransactions to update
     */
    where?: CardTransactionWhereInput
    /**
     * Limit how many CardTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CardTransaction upsert
   */
  export type CardTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CardTransaction to update in case it exists.
     */
    where: CardTransactionWhereUniqueInput
    /**
     * In case the CardTransaction found by the `where` argument doesn't exist, create a new CardTransaction with this data.
     */
    create: XOR<CardTransactionCreateInput, CardTransactionUncheckedCreateInput>
    /**
     * In case the CardTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardTransactionUpdateInput, CardTransactionUncheckedUpdateInput>
  }

  /**
   * CardTransaction delete
   */
  export type CardTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
    /**
     * Filter which CardTransaction to delete.
     */
    where: CardTransactionWhereUniqueInput
  }

  /**
   * CardTransaction deleteMany
   */
  export type CardTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardTransactions to delete
     */
    where?: CardTransactionWhereInput
    /**
     * Limit how many CardTransactions to delete.
     */
    limit?: number
  }

  /**
   * CardTransaction without action
   */
  export type CardTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardTransaction
     */
    select?: CardTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardTransaction
     */
    omit?: CardTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardTransactionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone_number: 'phone_number',
    password_hash: 'password_hash',
    role: 'role'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const LoansScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    amount: 'amount',
    interest_rate: 'interest_rate',
    term: 'term',
    status: 'status',
    created_at: 'created_at',
    monthly_payment_amount: 'monthly_payment_amount',
    outstanding_principal: 'outstanding_principal',
    paid_amount: 'paid_amount',
    next_payment_due_date: 'next_payment_due_date',
    last_payment_date: 'last_payment_date',
    activated_at: 'activated_at',
    accrued_penalty: 'accrued_penalty',
    last_penalty_calculation_date: 'last_penalty_calculation_date'
  };

  export type LoansScalarFieldEnum = (typeof LoansScalarFieldEnum)[keyof typeof LoansScalarFieldEnum]


  export const LoanPaymentScalarFieldEnum: {
    id: 'id',
    loan_id: 'loan_id',
    payment_date: 'payment_date',
    amount_paid: 'amount_paid',
    principal_paid: 'principal_paid',
    interest_paid: 'interest_paid',
    outstanding_principal_after_payment: 'outstanding_principal_after_payment',
    notes: 'notes'
  };

  export type LoanPaymentScalarFieldEnum = (typeof LoanPaymentScalarFieldEnum)[keyof typeof LoanPaymentScalarFieldEnum]


  export const DepositsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    amount: 'amount',
    interest_rate: 'interest_rate',
    term: 'term',
    status: 'status',
    created_at: 'created_at',
    approved_at: 'approved_at',
    maturity_date: 'maturity_date',
    closed_at: 'closed_at',
    calculated_accrued_interest: 'calculated_accrued_interest',
    calculated_total_payout: 'calculated_total_payout',
    early_withdrawal_requested_at: 'early_withdrawal_requested_at',
    early_withdrawal_penalty_percent: 'early_withdrawal_penalty_percent'
  };

  export type DepositsScalarFieldEnum = (typeof DepositsScalarFieldEnum)[keyof typeof DepositsScalarFieldEnum]


  export const CardsScalarFieldEnum: {
    id: 'id',
    card_number: 'card_number',
    cvv: 'cvv',
    holder_id: 'holder_id',
    pin: 'pin',
    balance: 'balance',
    dueDate: 'dueDate',
    status: 'status'
  };

  export type CardsScalarFieldEnum = (typeof CardsScalarFieldEnum)[keyof typeof CardsScalarFieldEnum]


  export const CardTransactionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    timestamp: 'timestamp',
    description: 'description',
    senderCardId: 'senderCardId',
    receiverCardId: 'receiverCardId'
  };

  export type CardTransactionScalarFieldEnum = (typeof CardTransactionScalarFieldEnum)[keyof typeof CardTransactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    senderId?: IntFilter<"ChatMessage"> | number
    receiverId?: IntFilter<"ChatMessage"> | number
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    Sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Receiver?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    Sender?: UsersOrderByWithRelationInput
    Receiver?: UsersOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    senderId?: IntFilter<"ChatMessage"> | number
    receiverId?: IntFilter<"ChatMessage"> | number
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    Sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Receiver?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _avg?: ChatMessageAvgOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
    _sum?: ChatMessageSumOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatMessage"> | number
    senderId?: IntWithAggregatesFilter<"ChatMessage"> | number
    receiverId?: IntWithAggregatesFilter<"ChatMessage"> | number
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: IntFilter<"Users"> | number
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    phone_number?: StringFilter<"Users"> | string
    password_hash?: StringFilter<"Users"> | string
    role?: StringFilter<"Users"> | string
    Loans?: LoansListRelationFilter
    Deposits?: DepositsListRelationFilter
    Cards?: CardsListRelationFilter
    SentMessages?: ChatMessageListRelationFilter
    ReceivedMessages?: ChatMessageListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    Loans?: LoansOrderByRelationAggregateInput
    Deposits?: DepositsOrderByRelationAggregateInput
    Cards?: CardsOrderByRelationAggregateInput
    SentMessages?: ChatMessageOrderByRelationAggregateInput
    ReceivedMessages?: ChatMessageOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phone_number?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    name?: StringFilter<"Users"> | string
    password_hash?: StringFilter<"Users"> | string
    role?: StringFilter<"Users"> | string
    Loans?: LoansListRelationFilter
    Deposits?: DepositsListRelationFilter
    Cards?: CardsListRelationFilter
    SentMessages?: ChatMessageListRelationFilter
    ReceivedMessages?: ChatMessageListRelationFilter
  }, "id" | "email" | "phone_number">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Users"> | number
    name?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    phone_number?: StringWithAggregatesFilter<"Users"> | string
    password_hash?: StringWithAggregatesFilter<"Users"> | string
    role?: StringWithAggregatesFilter<"Users"> | string
  }

  export type LoansWhereInput = {
    AND?: LoansWhereInput | LoansWhereInput[]
    OR?: LoansWhereInput[]
    NOT?: LoansWhereInput | LoansWhereInput[]
    id?: IntFilter<"Loans"> | number
    user_id?: IntFilter<"Loans"> | number
    amount?: FloatFilter<"Loans"> | number
    interest_rate?: FloatFilter<"Loans"> | number
    term?: IntFilter<"Loans"> | number
    status?: StringFilter<"Loans"> | string
    created_at?: DateTimeFilter<"Loans"> | Date | string
    monthly_payment_amount?: FloatNullableFilter<"Loans"> | number | null
    outstanding_principal?: FloatNullableFilter<"Loans"> | number | null
    paid_amount?: FloatNullableFilter<"Loans"> | number | null
    next_payment_due_date?: DateTimeNullableFilter<"Loans"> | Date | string | null
    last_payment_date?: DateTimeNullableFilter<"Loans"> | Date | string | null
    activated_at?: DateTimeNullableFilter<"Loans"> | Date | string | null
    accrued_penalty?: FloatNullableFilter<"Loans"> | number | null
    last_penalty_calculation_date?: DateTimeNullableFilter<"Loans"> | Date | string | null
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    LoanPayments?: LoanPaymentListRelationFilter
  }

  export type LoansOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    monthly_payment_amount?: SortOrderInput | SortOrder
    outstanding_principal?: SortOrderInput | SortOrder
    paid_amount?: SortOrderInput | SortOrder
    next_payment_due_date?: SortOrderInput | SortOrder
    last_payment_date?: SortOrderInput | SortOrder
    activated_at?: SortOrderInput | SortOrder
    accrued_penalty?: SortOrderInput | SortOrder
    last_penalty_calculation_date?: SortOrderInput | SortOrder
    Users?: UsersOrderByWithRelationInput
    LoanPayments?: LoanPaymentOrderByRelationAggregateInput
  }

  export type LoansWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LoansWhereInput | LoansWhereInput[]
    OR?: LoansWhereInput[]
    NOT?: LoansWhereInput | LoansWhereInput[]
    user_id?: IntFilter<"Loans"> | number
    amount?: FloatFilter<"Loans"> | number
    interest_rate?: FloatFilter<"Loans"> | number
    term?: IntFilter<"Loans"> | number
    status?: StringFilter<"Loans"> | string
    created_at?: DateTimeFilter<"Loans"> | Date | string
    monthly_payment_amount?: FloatNullableFilter<"Loans"> | number | null
    outstanding_principal?: FloatNullableFilter<"Loans"> | number | null
    paid_amount?: FloatNullableFilter<"Loans"> | number | null
    next_payment_due_date?: DateTimeNullableFilter<"Loans"> | Date | string | null
    last_payment_date?: DateTimeNullableFilter<"Loans"> | Date | string | null
    activated_at?: DateTimeNullableFilter<"Loans"> | Date | string | null
    accrued_penalty?: FloatNullableFilter<"Loans"> | number | null
    last_penalty_calculation_date?: DateTimeNullableFilter<"Loans"> | Date | string | null
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    LoanPayments?: LoanPaymentListRelationFilter
  }, "id">

  export type LoansOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    monthly_payment_amount?: SortOrderInput | SortOrder
    outstanding_principal?: SortOrderInput | SortOrder
    paid_amount?: SortOrderInput | SortOrder
    next_payment_due_date?: SortOrderInput | SortOrder
    last_payment_date?: SortOrderInput | SortOrder
    activated_at?: SortOrderInput | SortOrder
    accrued_penalty?: SortOrderInput | SortOrder
    last_penalty_calculation_date?: SortOrderInput | SortOrder
    _count?: LoansCountOrderByAggregateInput
    _avg?: LoansAvgOrderByAggregateInput
    _max?: LoansMaxOrderByAggregateInput
    _min?: LoansMinOrderByAggregateInput
    _sum?: LoansSumOrderByAggregateInput
  }

  export type LoansScalarWhereWithAggregatesInput = {
    AND?: LoansScalarWhereWithAggregatesInput | LoansScalarWhereWithAggregatesInput[]
    OR?: LoansScalarWhereWithAggregatesInput[]
    NOT?: LoansScalarWhereWithAggregatesInput | LoansScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Loans"> | number
    user_id?: IntWithAggregatesFilter<"Loans"> | number
    amount?: FloatWithAggregatesFilter<"Loans"> | number
    interest_rate?: FloatWithAggregatesFilter<"Loans"> | number
    term?: IntWithAggregatesFilter<"Loans"> | number
    status?: StringWithAggregatesFilter<"Loans"> | string
    created_at?: DateTimeWithAggregatesFilter<"Loans"> | Date | string
    monthly_payment_amount?: FloatNullableWithAggregatesFilter<"Loans"> | number | null
    outstanding_principal?: FloatNullableWithAggregatesFilter<"Loans"> | number | null
    paid_amount?: FloatNullableWithAggregatesFilter<"Loans"> | number | null
    next_payment_due_date?: DateTimeNullableWithAggregatesFilter<"Loans"> | Date | string | null
    last_payment_date?: DateTimeNullableWithAggregatesFilter<"Loans"> | Date | string | null
    activated_at?: DateTimeNullableWithAggregatesFilter<"Loans"> | Date | string | null
    accrued_penalty?: FloatNullableWithAggregatesFilter<"Loans"> | number | null
    last_penalty_calculation_date?: DateTimeNullableWithAggregatesFilter<"Loans"> | Date | string | null
  }

  export type LoanPaymentWhereInput = {
    AND?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    OR?: LoanPaymentWhereInput[]
    NOT?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    id?: IntFilter<"LoanPayment"> | number
    loan_id?: IntFilter<"LoanPayment"> | number
    payment_date?: DateTimeFilter<"LoanPayment"> | Date | string
    amount_paid?: FloatFilter<"LoanPayment"> | number
    principal_paid?: FloatFilter<"LoanPayment"> | number
    interest_paid?: FloatFilter<"LoanPayment"> | number
    outstanding_principal_after_payment?: FloatFilter<"LoanPayment"> | number
    notes?: StringNullableFilter<"LoanPayment"> | string | null
    Loan?: XOR<LoansScalarRelationFilter, LoansWhereInput>
  }

  export type LoanPaymentOrderByWithRelationInput = {
    id?: SortOrder
    loan_id?: SortOrder
    payment_date?: SortOrder
    amount_paid?: SortOrder
    principal_paid?: SortOrder
    interest_paid?: SortOrder
    outstanding_principal_after_payment?: SortOrder
    notes?: SortOrderInput | SortOrder
    Loan?: LoansOrderByWithRelationInput
  }

  export type LoanPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    OR?: LoanPaymentWhereInput[]
    NOT?: LoanPaymentWhereInput | LoanPaymentWhereInput[]
    loan_id?: IntFilter<"LoanPayment"> | number
    payment_date?: DateTimeFilter<"LoanPayment"> | Date | string
    amount_paid?: FloatFilter<"LoanPayment"> | number
    principal_paid?: FloatFilter<"LoanPayment"> | number
    interest_paid?: FloatFilter<"LoanPayment"> | number
    outstanding_principal_after_payment?: FloatFilter<"LoanPayment"> | number
    notes?: StringNullableFilter<"LoanPayment"> | string | null
    Loan?: XOR<LoansScalarRelationFilter, LoansWhereInput>
  }, "id">

  export type LoanPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    loan_id?: SortOrder
    payment_date?: SortOrder
    amount_paid?: SortOrder
    principal_paid?: SortOrder
    interest_paid?: SortOrder
    outstanding_principal_after_payment?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: LoanPaymentCountOrderByAggregateInput
    _avg?: LoanPaymentAvgOrderByAggregateInput
    _max?: LoanPaymentMaxOrderByAggregateInput
    _min?: LoanPaymentMinOrderByAggregateInput
    _sum?: LoanPaymentSumOrderByAggregateInput
  }

  export type LoanPaymentScalarWhereWithAggregatesInput = {
    AND?: LoanPaymentScalarWhereWithAggregatesInput | LoanPaymentScalarWhereWithAggregatesInput[]
    OR?: LoanPaymentScalarWhereWithAggregatesInput[]
    NOT?: LoanPaymentScalarWhereWithAggregatesInput | LoanPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LoanPayment"> | number
    loan_id?: IntWithAggregatesFilter<"LoanPayment"> | number
    payment_date?: DateTimeWithAggregatesFilter<"LoanPayment"> | Date | string
    amount_paid?: FloatWithAggregatesFilter<"LoanPayment"> | number
    principal_paid?: FloatWithAggregatesFilter<"LoanPayment"> | number
    interest_paid?: FloatWithAggregatesFilter<"LoanPayment"> | number
    outstanding_principal_after_payment?: FloatWithAggregatesFilter<"LoanPayment"> | number
    notes?: StringNullableWithAggregatesFilter<"LoanPayment"> | string | null
  }

  export type DepositsWhereInput = {
    AND?: DepositsWhereInput | DepositsWhereInput[]
    OR?: DepositsWhereInput[]
    NOT?: DepositsWhereInput | DepositsWhereInput[]
    id?: IntFilter<"Deposits"> | number
    user_id?: IntFilter<"Deposits"> | number
    amount?: FloatFilter<"Deposits"> | number
    interest_rate?: FloatFilter<"Deposits"> | number
    term?: IntFilter<"Deposits"> | number
    status?: StringFilter<"Deposits"> | string
    created_at?: DateTimeFilter<"Deposits"> | Date | string
    approved_at?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    maturity_date?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    calculated_accrued_interest?: FloatNullableFilter<"Deposits"> | number | null
    calculated_total_payout?: FloatNullableFilter<"Deposits"> | number | null
    early_withdrawal_requested_at?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    early_withdrawal_penalty_percent?: FloatNullableFilter<"Deposits"> | number | null
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type DepositsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    approved_at?: SortOrderInput | SortOrder
    maturity_date?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    calculated_accrued_interest?: SortOrderInput | SortOrder
    calculated_total_payout?: SortOrderInput | SortOrder
    early_withdrawal_requested_at?: SortOrderInput | SortOrder
    early_withdrawal_penalty_percent?: SortOrderInput | SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type DepositsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepositsWhereInput | DepositsWhereInput[]
    OR?: DepositsWhereInput[]
    NOT?: DepositsWhereInput | DepositsWhereInput[]
    user_id?: IntFilter<"Deposits"> | number
    amount?: FloatFilter<"Deposits"> | number
    interest_rate?: FloatFilter<"Deposits"> | number
    term?: IntFilter<"Deposits"> | number
    status?: StringFilter<"Deposits"> | string
    created_at?: DateTimeFilter<"Deposits"> | Date | string
    approved_at?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    maturity_date?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    calculated_accrued_interest?: FloatNullableFilter<"Deposits"> | number | null
    calculated_total_payout?: FloatNullableFilter<"Deposits"> | number | null
    early_withdrawal_requested_at?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    early_withdrawal_penalty_percent?: FloatNullableFilter<"Deposits"> | number | null
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type DepositsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    approved_at?: SortOrderInput | SortOrder
    maturity_date?: SortOrderInput | SortOrder
    closed_at?: SortOrderInput | SortOrder
    calculated_accrued_interest?: SortOrderInput | SortOrder
    calculated_total_payout?: SortOrderInput | SortOrder
    early_withdrawal_requested_at?: SortOrderInput | SortOrder
    early_withdrawal_penalty_percent?: SortOrderInput | SortOrder
    _count?: DepositsCountOrderByAggregateInput
    _avg?: DepositsAvgOrderByAggregateInput
    _max?: DepositsMaxOrderByAggregateInput
    _min?: DepositsMinOrderByAggregateInput
    _sum?: DepositsSumOrderByAggregateInput
  }

  export type DepositsScalarWhereWithAggregatesInput = {
    AND?: DepositsScalarWhereWithAggregatesInput | DepositsScalarWhereWithAggregatesInput[]
    OR?: DepositsScalarWhereWithAggregatesInput[]
    NOT?: DepositsScalarWhereWithAggregatesInput | DepositsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Deposits"> | number
    user_id?: IntWithAggregatesFilter<"Deposits"> | number
    amount?: FloatWithAggregatesFilter<"Deposits"> | number
    interest_rate?: FloatWithAggregatesFilter<"Deposits"> | number
    term?: IntWithAggregatesFilter<"Deposits"> | number
    status?: StringWithAggregatesFilter<"Deposits"> | string
    created_at?: DateTimeWithAggregatesFilter<"Deposits"> | Date | string
    approved_at?: DateTimeNullableWithAggregatesFilter<"Deposits"> | Date | string | null
    maturity_date?: DateTimeNullableWithAggregatesFilter<"Deposits"> | Date | string | null
    closed_at?: DateTimeNullableWithAggregatesFilter<"Deposits"> | Date | string | null
    calculated_accrued_interest?: FloatNullableWithAggregatesFilter<"Deposits"> | number | null
    calculated_total_payout?: FloatNullableWithAggregatesFilter<"Deposits"> | number | null
    early_withdrawal_requested_at?: DateTimeNullableWithAggregatesFilter<"Deposits"> | Date | string | null
    early_withdrawal_penalty_percent?: FloatNullableWithAggregatesFilter<"Deposits"> | number | null
  }

  export type CardsWhereInput = {
    AND?: CardsWhereInput | CardsWhereInput[]
    OR?: CardsWhereInput[]
    NOT?: CardsWhereInput | CardsWhereInput[]
    id?: IntFilter<"Cards"> | number
    card_number?: StringFilter<"Cards"> | string
    cvv?: IntFilter<"Cards"> | number
    holder_id?: IntFilter<"Cards"> | number
    pin?: IntFilter<"Cards"> | number
    balance?: FloatFilter<"Cards"> | number
    dueDate?: StringFilter<"Cards"> | string
    status?: StringFilter<"Cards"> | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    SentTransactions?: CardTransactionListRelationFilter
    ReceivedTransactions?: CardTransactionListRelationFilter
  }

  export type CardsOrderByWithRelationInput = {
    id?: SortOrder
    card_number?: SortOrder
    cvv?: SortOrder
    holder_id?: SortOrder
    pin?: SortOrder
    balance?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    Users?: UsersOrderByWithRelationInput
    SentTransactions?: CardTransactionOrderByRelationAggregateInput
    ReceivedTransactions?: CardTransactionOrderByRelationAggregateInput
  }

  export type CardsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    card_number?: string
    AND?: CardsWhereInput | CardsWhereInput[]
    OR?: CardsWhereInput[]
    NOT?: CardsWhereInput | CardsWhereInput[]
    cvv?: IntFilter<"Cards"> | number
    holder_id?: IntFilter<"Cards"> | number
    pin?: IntFilter<"Cards"> | number
    balance?: FloatFilter<"Cards"> | number
    dueDate?: StringFilter<"Cards"> | string
    status?: StringFilter<"Cards"> | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    SentTransactions?: CardTransactionListRelationFilter
    ReceivedTransactions?: CardTransactionListRelationFilter
  }, "id" | "card_number">

  export type CardsOrderByWithAggregationInput = {
    id?: SortOrder
    card_number?: SortOrder
    cvv?: SortOrder
    holder_id?: SortOrder
    pin?: SortOrder
    balance?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    _count?: CardsCountOrderByAggregateInput
    _avg?: CardsAvgOrderByAggregateInput
    _max?: CardsMaxOrderByAggregateInput
    _min?: CardsMinOrderByAggregateInput
    _sum?: CardsSumOrderByAggregateInput
  }

  export type CardsScalarWhereWithAggregatesInput = {
    AND?: CardsScalarWhereWithAggregatesInput | CardsScalarWhereWithAggregatesInput[]
    OR?: CardsScalarWhereWithAggregatesInput[]
    NOT?: CardsScalarWhereWithAggregatesInput | CardsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cards"> | number
    card_number?: StringWithAggregatesFilter<"Cards"> | string
    cvv?: IntWithAggregatesFilter<"Cards"> | number
    holder_id?: IntWithAggregatesFilter<"Cards"> | number
    pin?: IntWithAggregatesFilter<"Cards"> | number
    balance?: FloatWithAggregatesFilter<"Cards"> | number
    dueDate?: StringWithAggregatesFilter<"Cards"> | string
    status?: StringWithAggregatesFilter<"Cards"> | string
  }

  export type CardTransactionWhereInput = {
    AND?: CardTransactionWhereInput | CardTransactionWhereInput[]
    OR?: CardTransactionWhereInput[]
    NOT?: CardTransactionWhereInput | CardTransactionWhereInput[]
    id?: IntFilter<"CardTransaction"> | number
    amount?: FloatFilter<"CardTransaction"> | number
    timestamp?: DateTimeFilter<"CardTransaction"> | Date | string
    description?: StringFilter<"CardTransaction"> | string
    senderCardId?: IntFilter<"CardTransaction"> | number
    receiverCardId?: IntFilter<"CardTransaction"> | number
    SenderCard?: XOR<CardsScalarRelationFilter, CardsWhereInput>
    ReceiverCard?: XOR<CardsScalarRelationFilter, CardsWhereInput>
  }

  export type CardTransactionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    senderCardId?: SortOrder
    receiverCardId?: SortOrder
    SenderCard?: CardsOrderByWithRelationInput
    ReceiverCard?: CardsOrderByWithRelationInput
  }

  export type CardTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CardTransactionWhereInput | CardTransactionWhereInput[]
    OR?: CardTransactionWhereInput[]
    NOT?: CardTransactionWhereInput | CardTransactionWhereInput[]
    amount?: FloatFilter<"CardTransaction"> | number
    timestamp?: DateTimeFilter<"CardTransaction"> | Date | string
    description?: StringFilter<"CardTransaction"> | string
    senderCardId?: IntFilter<"CardTransaction"> | number
    receiverCardId?: IntFilter<"CardTransaction"> | number
    SenderCard?: XOR<CardsScalarRelationFilter, CardsWhereInput>
    ReceiverCard?: XOR<CardsScalarRelationFilter, CardsWhereInput>
  }, "id">

  export type CardTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    senderCardId?: SortOrder
    receiverCardId?: SortOrder
    _count?: CardTransactionCountOrderByAggregateInput
    _avg?: CardTransactionAvgOrderByAggregateInput
    _max?: CardTransactionMaxOrderByAggregateInput
    _min?: CardTransactionMinOrderByAggregateInput
    _sum?: CardTransactionSumOrderByAggregateInput
  }

  export type CardTransactionScalarWhereWithAggregatesInput = {
    AND?: CardTransactionScalarWhereWithAggregatesInput | CardTransactionScalarWhereWithAggregatesInput[]
    OR?: CardTransactionScalarWhereWithAggregatesInput[]
    NOT?: CardTransactionScalarWhereWithAggregatesInput | CardTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CardTransaction"> | number
    amount?: FloatWithAggregatesFilter<"CardTransaction"> | number
    timestamp?: DateTimeWithAggregatesFilter<"CardTransaction"> | Date | string
    description?: StringWithAggregatesFilter<"CardTransaction"> | string
    senderCardId?: IntWithAggregatesFilter<"CardTransaction"> | number
    receiverCardId?: IntWithAggregatesFilter<"CardTransaction"> | number
  }

  export type ChatMessageCreateInput = {
    content: string
    createdAt?: Date | string
    Sender: UsersCreateNestedOneWithoutSentMessagesInput
    Receiver: UsersCreateNestedOneWithoutReceivedMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: number
    senderId: number
    receiverId: number
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sender?: UsersUpdateOneRequiredWithoutSentMessagesNestedInput
    Receiver?: UsersUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: number
    senderId: number
    receiverId: number
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersCreateInput = {
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Loans?: LoansCreateNestedManyWithoutUsersInput
    Deposits?: DepositsCreateNestedManyWithoutUsersInput
    Cards?: CardsCreateNestedManyWithoutUsersInput
    SentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UsersUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Loans?: LoansUncheckedCreateNestedManyWithoutUsersInput
    Deposits?: DepositsUncheckedCreateNestedManyWithoutUsersInput
    Cards?: CardsUncheckedCreateNestedManyWithoutUsersInput
    SentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UsersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Loans?: LoansUpdateManyWithoutUsersNestedInput
    Deposits?: DepositsUpdateManyWithoutUsersNestedInput
    Cards?: CardsUpdateManyWithoutUsersNestedInput
    SentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    ReceivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Loans?: LoansUncheckedUpdateManyWithoutUsersNestedInput
    Deposits?: DepositsUncheckedUpdateManyWithoutUsersNestedInput
    Cards?: CardsUncheckedUpdateManyWithoutUsersNestedInput
    SentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    ReceivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UsersCreateManyInput = {
    id?: number
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
  }

  export type UsersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type LoansCreateInput = {
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    monthly_payment_amount?: number | null
    outstanding_principal?: number | null
    paid_amount?: number | null
    next_payment_due_date?: Date | string | null
    last_payment_date?: Date | string | null
    activated_at?: Date | string | null
    accrued_penalty?: number | null
    last_penalty_calculation_date?: Date | string | null
    Users: UsersCreateNestedOneWithoutLoansInput
    LoanPayments?: LoanPaymentCreateNestedManyWithoutLoanInput
  }

  export type LoansUncheckedCreateInput = {
    id?: number
    user_id: number
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    monthly_payment_amount?: number | null
    outstanding_principal?: number | null
    paid_amount?: number | null
    next_payment_due_date?: Date | string | null
    last_payment_date?: Date | string | null
    activated_at?: Date | string | null
    accrued_penalty?: number | null
    last_penalty_calculation_date?: Date | string | null
    LoanPayments?: LoanPaymentUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoansUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    outstanding_principal?: NullableFloatFieldUpdateOperationsInput | number | null
    paid_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    next_payment_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accrued_penalty?: NullableFloatFieldUpdateOperationsInput | number | null
    last_penalty_calculation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutLoansNestedInput
    LoanPayments?: LoanPaymentUpdateManyWithoutLoanNestedInput
  }

  export type LoansUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    outstanding_principal?: NullableFloatFieldUpdateOperationsInput | number | null
    paid_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    next_payment_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accrued_penalty?: NullableFloatFieldUpdateOperationsInput | number | null
    last_penalty_calculation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LoanPayments?: LoanPaymentUncheckedUpdateManyWithoutLoanNestedInput
  }

  export type LoansCreateManyInput = {
    id?: number
    user_id: number
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    monthly_payment_amount?: number | null
    outstanding_principal?: number | null
    paid_amount?: number | null
    next_payment_due_date?: Date | string | null
    last_payment_date?: Date | string | null
    activated_at?: Date | string | null
    accrued_penalty?: number | null
    last_penalty_calculation_date?: Date | string | null
  }

  export type LoansUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    outstanding_principal?: NullableFloatFieldUpdateOperationsInput | number | null
    paid_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    next_payment_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accrued_penalty?: NullableFloatFieldUpdateOperationsInput | number | null
    last_penalty_calculation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LoansUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    outstanding_principal?: NullableFloatFieldUpdateOperationsInput | number | null
    paid_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    next_payment_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accrued_penalty?: NullableFloatFieldUpdateOperationsInput | number | null
    last_penalty_calculation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LoanPaymentCreateInput = {
    payment_date?: Date | string
    amount_paid: number
    principal_paid: number
    interest_paid: number
    outstanding_principal_after_payment: number
    notes?: string | null
    Loan: LoansCreateNestedOneWithoutLoanPaymentsInput
  }

  export type LoanPaymentUncheckedCreateInput = {
    id?: number
    loan_id: number
    payment_date?: Date | string
    amount_paid: number
    principal_paid: number
    interest_paid: number
    outstanding_principal_after_payment: number
    notes?: string | null
  }

  export type LoanPaymentUpdateInput = {
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: FloatFieldUpdateOperationsInput | number
    principal_paid?: FloatFieldUpdateOperationsInput | number
    interest_paid?: FloatFieldUpdateOperationsInput | number
    outstanding_principal_after_payment?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    Loan?: LoansUpdateOneRequiredWithoutLoanPaymentsNestedInput
  }

  export type LoanPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loan_id?: IntFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: FloatFieldUpdateOperationsInput | number
    principal_paid?: FloatFieldUpdateOperationsInput | number
    interest_paid?: FloatFieldUpdateOperationsInput | number
    outstanding_principal_after_payment?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoanPaymentCreateManyInput = {
    id?: number
    loan_id: number
    payment_date?: Date | string
    amount_paid: number
    principal_paid: number
    interest_paid: number
    outstanding_principal_after_payment: number
    notes?: string | null
  }

  export type LoanPaymentUpdateManyMutationInput = {
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: FloatFieldUpdateOperationsInput | number
    principal_paid?: FloatFieldUpdateOperationsInput | number
    interest_paid?: FloatFieldUpdateOperationsInput | number
    outstanding_principal_after_payment?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoanPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loan_id?: IntFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: FloatFieldUpdateOperationsInput | number
    principal_paid?: FloatFieldUpdateOperationsInput | number
    interest_paid?: FloatFieldUpdateOperationsInput | number
    outstanding_principal_after_payment?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepositsCreateInput = {
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    approved_at?: Date | string | null
    maturity_date?: Date | string | null
    closed_at?: Date | string | null
    calculated_accrued_interest?: number | null
    calculated_total_payout?: number | null
    early_withdrawal_requested_at?: Date | string | null
    early_withdrawal_penalty_percent?: number | null
    Users: UsersCreateNestedOneWithoutDepositsInput
  }

  export type DepositsUncheckedCreateInput = {
    id?: number
    user_id: number
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    approved_at?: Date | string | null
    maturity_date?: Date | string | null
    closed_at?: Date | string | null
    calculated_accrued_interest?: number | null
    calculated_total_payout?: number | null
    early_withdrawal_requested_at?: Date | string | null
    early_withdrawal_penalty_percent?: number | null
  }

  export type DepositsUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calculated_accrued_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculated_total_payout?: NullableFloatFieldUpdateOperationsInput | number | null
    early_withdrawal_requested_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_withdrawal_penalty_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    Users?: UsersUpdateOneRequiredWithoutDepositsNestedInput
  }

  export type DepositsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calculated_accrued_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculated_total_payout?: NullableFloatFieldUpdateOperationsInput | number | null
    early_withdrawal_requested_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_withdrawal_penalty_percent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DepositsCreateManyInput = {
    id?: number
    user_id: number
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    approved_at?: Date | string | null
    maturity_date?: Date | string | null
    closed_at?: Date | string | null
    calculated_accrued_interest?: number | null
    calculated_total_payout?: number | null
    early_withdrawal_requested_at?: Date | string | null
    early_withdrawal_penalty_percent?: number | null
  }

  export type DepositsUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calculated_accrued_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculated_total_payout?: NullableFloatFieldUpdateOperationsInput | number | null
    early_withdrawal_requested_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_withdrawal_penalty_percent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DepositsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calculated_accrued_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculated_total_payout?: NullableFloatFieldUpdateOperationsInput | number | null
    early_withdrawal_requested_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_withdrawal_penalty_percent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CardsCreateInput = {
    card_number: string
    cvv: number
    pin: number
    balance: number
    dueDate: string
    status?: string
    Users: UsersCreateNestedOneWithoutCardsInput
    SentTransactions?: CardTransactionCreateNestedManyWithoutSenderCardInput
    ReceivedTransactions?: CardTransactionCreateNestedManyWithoutReceiverCardInput
  }

  export type CardsUncheckedCreateInput = {
    id?: number
    card_number: string
    cvv: number
    holder_id: number
    pin: number
    balance: number
    dueDate: string
    status?: string
    SentTransactions?: CardTransactionUncheckedCreateNestedManyWithoutSenderCardInput
    ReceivedTransactions?: CardTransactionUncheckedCreateNestedManyWithoutReceiverCardInput
  }

  export type CardsUpdateInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneRequiredWithoutCardsNestedInput
    SentTransactions?: CardTransactionUpdateManyWithoutSenderCardNestedInput
    ReceivedTransactions?: CardTransactionUpdateManyWithoutReceiverCardNestedInput
  }

  export type CardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    holder_id?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    SentTransactions?: CardTransactionUncheckedUpdateManyWithoutSenderCardNestedInput
    ReceivedTransactions?: CardTransactionUncheckedUpdateManyWithoutReceiverCardNestedInput
  }

  export type CardsCreateManyInput = {
    id?: number
    card_number: string
    cvv: number
    holder_id: number
    pin: number
    balance: number
    dueDate: string
    status?: string
  }

  export type CardsUpdateManyMutationInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    holder_id?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CardTransactionCreateInput = {
    amount: number
    timestamp?: Date | string
    description: string
    SenderCard: CardsCreateNestedOneWithoutSentTransactionsInput
    ReceiverCard: CardsCreateNestedOneWithoutReceivedTransactionsInput
  }

  export type CardTransactionUncheckedCreateInput = {
    id?: number
    amount: number
    timestamp?: Date | string
    description: string
    senderCardId: number
    receiverCardId: number
  }

  export type CardTransactionUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    SenderCard?: CardsUpdateOneRequiredWithoutSentTransactionsNestedInput
    ReceiverCard?: CardsUpdateOneRequiredWithoutReceivedTransactionsNestedInput
  }

  export type CardTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    senderCardId?: IntFieldUpdateOperationsInput | number
    receiverCardId?: IntFieldUpdateOperationsInput | number
  }

  export type CardTransactionCreateManyInput = {
    id?: number
    amount: number
    timestamp?: Date | string
    description: string
    senderCardId: number
    receiverCardId: number
  }

  export type CardTransactionUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type CardTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    senderCardId?: IntFieldUpdateOperationsInput | number
    receiverCardId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type LoansListRelationFilter = {
    every?: LoansWhereInput
    some?: LoansWhereInput
    none?: LoansWhereInput
  }

  export type DepositsListRelationFilter = {
    every?: DepositsWhereInput
    some?: DepositsWhereInput
    none?: DepositsWhereInput
  }

  export type CardsListRelationFilter = {
    every?: CardsWhereInput
    some?: CardsWhereInput
    none?: CardsWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type LoansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepositsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type LoanPaymentListRelationFilter = {
    every?: LoanPaymentWhereInput
    some?: LoanPaymentWhereInput
    none?: LoanPaymentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LoanPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoansCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    monthly_payment_amount?: SortOrder
    outstanding_principal?: SortOrder
    paid_amount?: SortOrder
    next_payment_due_date?: SortOrder
    last_payment_date?: SortOrder
    activated_at?: SortOrder
    accrued_penalty?: SortOrder
    last_penalty_calculation_date?: SortOrder
  }

  export type LoansAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    monthly_payment_amount?: SortOrder
    outstanding_principal?: SortOrder
    paid_amount?: SortOrder
    accrued_penalty?: SortOrder
  }

  export type LoansMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    monthly_payment_amount?: SortOrder
    outstanding_principal?: SortOrder
    paid_amount?: SortOrder
    next_payment_due_date?: SortOrder
    last_payment_date?: SortOrder
    activated_at?: SortOrder
    accrued_penalty?: SortOrder
    last_penalty_calculation_date?: SortOrder
  }

  export type LoansMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    monthly_payment_amount?: SortOrder
    outstanding_principal?: SortOrder
    paid_amount?: SortOrder
    next_payment_due_date?: SortOrder
    last_payment_date?: SortOrder
    activated_at?: SortOrder
    accrued_penalty?: SortOrder
    last_penalty_calculation_date?: SortOrder
  }

  export type LoansSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    monthly_payment_amount?: SortOrder
    outstanding_principal?: SortOrder
    paid_amount?: SortOrder
    accrued_penalty?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type LoansScalarRelationFilter = {
    is?: LoansWhereInput
    isNot?: LoansWhereInput
  }

  export type LoanPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    loan_id?: SortOrder
    payment_date?: SortOrder
    amount_paid?: SortOrder
    principal_paid?: SortOrder
    interest_paid?: SortOrder
    outstanding_principal_after_payment?: SortOrder
    notes?: SortOrder
  }

  export type LoanPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    loan_id?: SortOrder
    amount_paid?: SortOrder
    principal_paid?: SortOrder
    interest_paid?: SortOrder
    outstanding_principal_after_payment?: SortOrder
  }

  export type LoanPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    loan_id?: SortOrder
    payment_date?: SortOrder
    amount_paid?: SortOrder
    principal_paid?: SortOrder
    interest_paid?: SortOrder
    outstanding_principal_after_payment?: SortOrder
    notes?: SortOrder
  }

  export type LoanPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    loan_id?: SortOrder
    payment_date?: SortOrder
    amount_paid?: SortOrder
    principal_paid?: SortOrder
    interest_paid?: SortOrder
    outstanding_principal_after_payment?: SortOrder
    notes?: SortOrder
  }

  export type LoanPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    loan_id?: SortOrder
    amount_paid?: SortOrder
    principal_paid?: SortOrder
    interest_paid?: SortOrder
    outstanding_principal_after_payment?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DepositsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    approved_at?: SortOrder
    maturity_date?: SortOrder
    closed_at?: SortOrder
    calculated_accrued_interest?: SortOrder
    calculated_total_payout?: SortOrder
    early_withdrawal_requested_at?: SortOrder
    early_withdrawal_penalty_percent?: SortOrder
  }

  export type DepositsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    calculated_accrued_interest?: SortOrder
    calculated_total_payout?: SortOrder
    early_withdrawal_penalty_percent?: SortOrder
  }

  export type DepositsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    approved_at?: SortOrder
    maturity_date?: SortOrder
    closed_at?: SortOrder
    calculated_accrued_interest?: SortOrder
    calculated_total_payout?: SortOrder
    early_withdrawal_requested_at?: SortOrder
    early_withdrawal_penalty_percent?: SortOrder
  }

  export type DepositsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    approved_at?: SortOrder
    maturity_date?: SortOrder
    closed_at?: SortOrder
    calculated_accrued_interest?: SortOrder
    calculated_total_payout?: SortOrder
    early_withdrawal_requested_at?: SortOrder
    early_withdrawal_penalty_percent?: SortOrder
  }

  export type DepositsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    interest_rate?: SortOrder
    term?: SortOrder
    calculated_accrued_interest?: SortOrder
    calculated_total_payout?: SortOrder
    early_withdrawal_penalty_percent?: SortOrder
  }

  export type CardTransactionListRelationFilter = {
    every?: CardTransactionWhereInput
    some?: CardTransactionWhereInput
    none?: CardTransactionWhereInput
  }

  export type CardTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CardsCountOrderByAggregateInput = {
    id?: SortOrder
    card_number?: SortOrder
    cvv?: SortOrder
    holder_id?: SortOrder
    pin?: SortOrder
    balance?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
  }

  export type CardsAvgOrderByAggregateInput = {
    id?: SortOrder
    cvv?: SortOrder
    holder_id?: SortOrder
    pin?: SortOrder
    balance?: SortOrder
  }

  export type CardsMaxOrderByAggregateInput = {
    id?: SortOrder
    card_number?: SortOrder
    cvv?: SortOrder
    holder_id?: SortOrder
    pin?: SortOrder
    balance?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
  }

  export type CardsMinOrderByAggregateInput = {
    id?: SortOrder
    card_number?: SortOrder
    cvv?: SortOrder
    holder_id?: SortOrder
    pin?: SortOrder
    balance?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
  }

  export type CardsSumOrderByAggregateInput = {
    id?: SortOrder
    cvv?: SortOrder
    holder_id?: SortOrder
    pin?: SortOrder
    balance?: SortOrder
  }

  export type CardsScalarRelationFilter = {
    is?: CardsWhereInput
    isNot?: CardsWhereInput
  }

  export type CardTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    senderCardId?: SortOrder
    receiverCardId?: SortOrder
  }

  export type CardTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    senderCardId?: SortOrder
    receiverCardId?: SortOrder
  }

  export type CardTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    senderCardId?: SortOrder
    receiverCardId?: SortOrder
  }

  export type CardTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
    senderCardId?: SortOrder
    receiverCardId?: SortOrder
  }

  export type CardTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    senderCardId?: SortOrder
    receiverCardId?: SortOrder
  }

  export type UsersCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UsersCreateWithoutSentMessagesInput, UsersUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSentMessagesInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UsersCreateWithoutReceivedMessagesInput, UsersUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReceivedMessagesInput
    connect?: UsersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsersUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UsersCreateWithoutSentMessagesInput, UsersUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutSentMessagesInput
    upsert?: UsersUpsertWithoutSentMessagesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutSentMessagesInput, UsersUpdateWithoutSentMessagesInput>, UsersUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UsersUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UsersCreateWithoutReceivedMessagesInput, UsersUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UsersUpsertWithoutReceivedMessagesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutReceivedMessagesInput, UsersUpdateWithoutReceivedMessagesInput>, UsersUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LoansCreateNestedManyWithoutUsersInput = {
    create?: XOR<LoansCreateWithoutUsersInput, LoansUncheckedCreateWithoutUsersInput> | LoansCreateWithoutUsersInput[] | LoansUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LoansCreateOrConnectWithoutUsersInput | LoansCreateOrConnectWithoutUsersInput[]
    createMany?: LoansCreateManyUsersInputEnvelope
    connect?: LoansWhereUniqueInput | LoansWhereUniqueInput[]
  }

  export type DepositsCreateNestedManyWithoutUsersInput = {
    create?: XOR<DepositsCreateWithoutUsersInput, DepositsUncheckedCreateWithoutUsersInput> | DepositsCreateWithoutUsersInput[] | DepositsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DepositsCreateOrConnectWithoutUsersInput | DepositsCreateOrConnectWithoutUsersInput[]
    createMany?: DepositsCreateManyUsersInputEnvelope
    connect?: DepositsWhereUniqueInput | DepositsWhereUniqueInput[]
  }

  export type CardsCreateNestedManyWithoutUsersInput = {
    create?: XOR<CardsCreateWithoutUsersInput, CardsUncheckedCreateWithoutUsersInput> | CardsCreateWithoutUsersInput[] | CardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CardsCreateOrConnectWithoutUsersInput | CardsCreateOrConnectWithoutUsersInput[]
    createMany?: CardsCreateManyUsersInputEnvelope
    connect?: CardsWhereUniqueInput | CardsWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type LoansUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<LoansCreateWithoutUsersInput, LoansUncheckedCreateWithoutUsersInput> | LoansCreateWithoutUsersInput[] | LoansUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LoansCreateOrConnectWithoutUsersInput | LoansCreateOrConnectWithoutUsersInput[]
    createMany?: LoansCreateManyUsersInputEnvelope
    connect?: LoansWhereUniqueInput | LoansWhereUniqueInput[]
  }

  export type DepositsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<DepositsCreateWithoutUsersInput, DepositsUncheckedCreateWithoutUsersInput> | DepositsCreateWithoutUsersInput[] | DepositsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DepositsCreateOrConnectWithoutUsersInput | DepositsCreateOrConnectWithoutUsersInput[]
    createMany?: DepositsCreateManyUsersInputEnvelope
    connect?: DepositsWhereUniqueInput | DepositsWhereUniqueInput[]
  }

  export type CardsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<CardsCreateWithoutUsersInput, CardsUncheckedCreateWithoutUsersInput> | CardsCreateWithoutUsersInput[] | CardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CardsCreateOrConnectWithoutUsersInput | CardsCreateOrConnectWithoutUsersInput[]
    createMany?: CardsCreateManyUsersInputEnvelope
    connect?: CardsWhereUniqueInput | CardsWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type LoansUpdateManyWithoutUsersNestedInput = {
    create?: XOR<LoansCreateWithoutUsersInput, LoansUncheckedCreateWithoutUsersInput> | LoansCreateWithoutUsersInput[] | LoansUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LoansCreateOrConnectWithoutUsersInput | LoansCreateOrConnectWithoutUsersInput[]
    upsert?: LoansUpsertWithWhereUniqueWithoutUsersInput | LoansUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: LoansCreateManyUsersInputEnvelope
    set?: LoansWhereUniqueInput | LoansWhereUniqueInput[]
    disconnect?: LoansWhereUniqueInput | LoansWhereUniqueInput[]
    delete?: LoansWhereUniqueInput | LoansWhereUniqueInput[]
    connect?: LoansWhereUniqueInput | LoansWhereUniqueInput[]
    update?: LoansUpdateWithWhereUniqueWithoutUsersInput | LoansUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: LoansUpdateManyWithWhereWithoutUsersInput | LoansUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: LoansScalarWhereInput | LoansScalarWhereInput[]
  }

  export type DepositsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<DepositsCreateWithoutUsersInput, DepositsUncheckedCreateWithoutUsersInput> | DepositsCreateWithoutUsersInput[] | DepositsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DepositsCreateOrConnectWithoutUsersInput | DepositsCreateOrConnectWithoutUsersInput[]
    upsert?: DepositsUpsertWithWhereUniqueWithoutUsersInput | DepositsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: DepositsCreateManyUsersInputEnvelope
    set?: DepositsWhereUniqueInput | DepositsWhereUniqueInput[]
    disconnect?: DepositsWhereUniqueInput | DepositsWhereUniqueInput[]
    delete?: DepositsWhereUniqueInput | DepositsWhereUniqueInput[]
    connect?: DepositsWhereUniqueInput | DepositsWhereUniqueInput[]
    update?: DepositsUpdateWithWhereUniqueWithoutUsersInput | DepositsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: DepositsUpdateManyWithWhereWithoutUsersInput | DepositsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: DepositsScalarWhereInput | DepositsScalarWhereInput[]
  }

  export type CardsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CardsCreateWithoutUsersInput, CardsUncheckedCreateWithoutUsersInput> | CardsCreateWithoutUsersInput[] | CardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CardsCreateOrConnectWithoutUsersInput | CardsCreateOrConnectWithoutUsersInput[]
    upsert?: CardsUpsertWithWhereUniqueWithoutUsersInput | CardsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CardsCreateManyUsersInputEnvelope
    set?: CardsWhereUniqueInput | CardsWhereUniqueInput[]
    disconnect?: CardsWhereUniqueInput | CardsWhereUniqueInput[]
    delete?: CardsWhereUniqueInput | CardsWhereUniqueInput[]
    connect?: CardsWhereUniqueInput | CardsWhereUniqueInput[]
    update?: CardsUpdateWithWhereUniqueWithoutUsersInput | CardsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CardsUpdateManyWithWhereWithoutUsersInput | CardsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CardsScalarWhereInput | CardsScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutReceiverInput | ChatMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutReceiverInput | ChatMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutReceiverInput | ChatMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type LoansUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<LoansCreateWithoutUsersInput, LoansUncheckedCreateWithoutUsersInput> | LoansCreateWithoutUsersInput[] | LoansUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LoansCreateOrConnectWithoutUsersInput | LoansCreateOrConnectWithoutUsersInput[]
    upsert?: LoansUpsertWithWhereUniqueWithoutUsersInput | LoansUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: LoansCreateManyUsersInputEnvelope
    set?: LoansWhereUniqueInput | LoansWhereUniqueInput[]
    disconnect?: LoansWhereUniqueInput | LoansWhereUniqueInput[]
    delete?: LoansWhereUniqueInput | LoansWhereUniqueInput[]
    connect?: LoansWhereUniqueInput | LoansWhereUniqueInput[]
    update?: LoansUpdateWithWhereUniqueWithoutUsersInput | LoansUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: LoansUpdateManyWithWhereWithoutUsersInput | LoansUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: LoansScalarWhereInput | LoansScalarWhereInput[]
  }

  export type DepositsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<DepositsCreateWithoutUsersInput, DepositsUncheckedCreateWithoutUsersInput> | DepositsCreateWithoutUsersInput[] | DepositsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: DepositsCreateOrConnectWithoutUsersInput | DepositsCreateOrConnectWithoutUsersInput[]
    upsert?: DepositsUpsertWithWhereUniqueWithoutUsersInput | DepositsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: DepositsCreateManyUsersInputEnvelope
    set?: DepositsWhereUniqueInput | DepositsWhereUniqueInput[]
    disconnect?: DepositsWhereUniqueInput | DepositsWhereUniqueInput[]
    delete?: DepositsWhereUniqueInput | DepositsWhereUniqueInput[]
    connect?: DepositsWhereUniqueInput | DepositsWhereUniqueInput[]
    update?: DepositsUpdateWithWhereUniqueWithoutUsersInput | DepositsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: DepositsUpdateManyWithWhereWithoutUsersInput | DepositsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: DepositsScalarWhereInput | DepositsScalarWhereInput[]
  }

  export type CardsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CardsCreateWithoutUsersInput, CardsUncheckedCreateWithoutUsersInput> | CardsCreateWithoutUsersInput[] | CardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CardsCreateOrConnectWithoutUsersInput | CardsCreateOrConnectWithoutUsersInput[]
    upsert?: CardsUpsertWithWhereUniqueWithoutUsersInput | CardsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CardsCreateManyUsersInputEnvelope
    set?: CardsWhereUniqueInput | CardsWhereUniqueInput[]
    disconnect?: CardsWhereUniqueInput | CardsWhereUniqueInput[]
    delete?: CardsWhereUniqueInput | CardsWhereUniqueInput[]
    connect?: CardsWhereUniqueInput | CardsWhereUniqueInput[]
    update?: CardsUpdateWithWhereUniqueWithoutUsersInput | CardsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CardsUpdateManyWithWhereWithoutUsersInput | CardsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CardsScalarWhereInput | CardsScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutReceiverInput | ChatMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutReceiverInput | ChatMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutReceiverInput | ChatMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutLoansInput = {
    create?: XOR<UsersCreateWithoutLoansInput, UsersUncheckedCreateWithoutLoansInput>
    connectOrCreate?: UsersCreateOrConnectWithoutLoansInput
    connect?: UsersWhereUniqueInput
  }

  export type LoanPaymentCreateNestedManyWithoutLoanInput = {
    create?: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput> | LoanPaymentCreateWithoutLoanInput[] | LoanPaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoanInput | LoanPaymentCreateOrConnectWithoutLoanInput[]
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
  }

  export type LoanPaymentUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput> | LoanPaymentCreateWithoutLoanInput[] | LoanPaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoanInput | LoanPaymentCreateOrConnectWithoutLoanInput[]
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UsersUpdateOneRequiredWithoutLoansNestedInput = {
    create?: XOR<UsersCreateWithoutLoansInput, UsersUncheckedCreateWithoutLoansInput>
    connectOrCreate?: UsersCreateOrConnectWithoutLoansInput
    upsert?: UsersUpsertWithoutLoansInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutLoansInput, UsersUpdateWithoutLoansInput>, UsersUncheckedUpdateWithoutLoansInput>
  }

  export type LoanPaymentUpdateManyWithoutLoanNestedInput = {
    create?: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput> | LoanPaymentCreateWithoutLoanInput[] | LoanPaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoanInput | LoanPaymentCreateOrConnectWithoutLoanInput[]
    upsert?: LoanPaymentUpsertWithWhereUniqueWithoutLoanInput | LoanPaymentUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    set?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    disconnect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    delete?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    update?: LoanPaymentUpdateWithWhereUniqueWithoutLoanInput | LoanPaymentUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: LoanPaymentUpdateManyWithWhereWithoutLoanInput | LoanPaymentUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
  }

  export type LoanPaymentUncheckedUpdateManyWithoutLoanNestedInput = {
    create?: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput> | LoanPaymentCreateWithoutLoanInput[] | LoanPaymentUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanPaymentCreateOrConnectWithoutLoanInput | LoanPaymentCreateOrConnectWithoutLoanInput[]
    upsert?: LoanPaymentUpsertWithWhereUniqueWithoutLoanInput | LoanPaymentUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: LoanPaymentCreateManyLoanInputEnvelope
    set?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    disconnect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    delete?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    connect?: LoanPaymentWhereUniqueInput | LoanPaymentWhereUniqueInput[]
    update?: LoanPaymentUpdateWithWhereUniqueWithoutLoanInput | LoanPaymentUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: LoanPaymentUpdateManyWithWhereWithoutLoanInput | LoanPaymentUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
  }

  export type LoansCreateNestedOneWithoutLoanPaymentsInput = {
    create?: XOR<LoansCreateWithoutLoanPaymentsInput, LoansUncheckedCreateWithoutLoanPaymentsInput>
    connectOrCreate?: LoansCreateOrConnectWithoutLoanPaymentsInput
    connect?: LoansWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type LoansUpdateOneRequiredWithoutLoanPaymentsNestedInput = {
    create?: XOR<LoansCreateWithoutLoanPaymentsInput, LoansUncheckedCreateWithoutLoanPaymentsInput>
    connectOrCreate?: LoansCreateOrConnectWithoutLoanPaymentsInput
    upsert?: LoansUpsertWithoutLoanPaymentsInput
    connect?: LoansWhereUniqueInput
    update?: XOR<XOR<LoansUpdateToOneWithWhereWithoutLoanPaymentsInput, LoansUpdateWithoutLoanPaymentsInput>, LoansUncheckedUpdateWithoutLoanPaymentsInput>
  }

  export type UsersCreateNestedOneWithoutDepositsInput = {
    create?: XOR<UsersCreateWithoutDepositsInput, UsersUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutDepositsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutDepositsNestedInput = {
    create?: XOR<UsersCreateWithoutDepositsInput, UsersUncheckedCreateWithoutDepositsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutDepositsInput
    upsert?: UsersUpsertWithoutDepositsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutDepositsInput, UsersUpdateWithoutDepositsInput>, UsersUncheckedUpdateWithoutDepositsInput>
  }

  export type UsersCreateNestedOneWithoutCardsInput = {
    create?: XOR<UsersCreateWithoutCardsInput, UsersUncheckedCreateWithoutCardsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCardsInput
    connect?: UsersWhereUniqueInput
  }

  export type CardTransactionCreateNestedManyWithoutSenderCardInput = {
    create?: XOR<CardTransactionCreateWithoutSenderCardInput, CardTransactionUncheckedCreateWithoutSenderCardInput> | CardTransactionCreateWithoutSenderCardInput[] | CardTransactionUncheckedCreateWithoutSenderCardInput[]
    connectOrCreate?: CardTransactionCreateOrConnectWithoutSenderCardInput | CardTransactionCreateOrConnectWithoutSenderCardInput[]
    createMany?: CardTransactionCreateManySenderCardInputEnvelope
    connect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
  }

  export type CardTransactionCreateNestedManyWithoutReceiverCardInput = {
    create?: XOR<CardTransactionCreateWithoutReceiverCardInput, CardTransactionUncheckedCreateWithoutReceiverCardInput> | CardTransactionCreateWithoutReceiverCardInput[] | CardTransactionUncheckedCreateWithoutReceiverCardInput[]
    connectOrCreate?: CardTransactionCreateOrConnectWithoutReceiverCardInput | CardTransactionCreateOrConnectWithoutReceiverCardInput[]
    createMany?: CardTransactionCreateManyReceiverCardInputEnvelope
    connect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
  }

  export type CardTransactionUncheckedCreateNestedManyWithoutSenderCardInput = {
    create?: XOR<CardTransactionCreateWithoutSenderCardInput, CardTransactionUncheckedCreateWithoutSenderCardInput> | CardTransactionCreateWithoutSenderCardInput[] | CardTransactionUncheckedCreateWithoutSenderCardInput[]
    connectOrCreate?: CardTransactionCreateOrConnectWithoutSenderCardInput | CardTransactionCreateOrConnectWithoutSenderCardInput[]
    createMany?: CardTransactionCreateManySenderCardInputEnvelope
    connect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
  }

  export type CardTransactionUncheckedCreateNestedManyWithoutReceiverCardInput = {
    create?: XOR<CardTransactionCreateWithoutReceiverCardInput, CardTransactionUncheckedCreateWithoutReceiverCardInput> | CardTransactionCreateWithoutReceiverCardInput[] | CardTransactionUncheckedCreateWithoutReceiverCardInput[]
    connectOrCreate?: CardTransactionCreateOrConnectWithoutReceiverCardInput | CardTransactionCreateOrConnectWithoutReceiverCardInput[]
    createMany?: CardTransactionCreateManyReceiverCardInputEnvelope
    connect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
  }

  export type UsersUpdateOneRequiredWithoutCardsNestedInput = {
    create?: XOR<UsersCreateWithoutCardsInput, UsersUncheckedCreateWithoutCardsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCardsInput
    upsert?: UsersUpsertWithoutCardsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCardsInput, UsersUpdateWithoutCardsInput>, UsersUncheckedUpdateWithoutCardsInput>
  }

  export type CardTransactionUpdateManyWithoutSenderCardNestedInput = {
    create?: XOR<CardTransactionCreateWithoutSenderCardInput, CardTransactionUncheckedCreateWithoutSenderCardInput> | CardTransactionCreateWithoutSenderCardInput[] | CardTransactionUncheckedCreateWithoutSenderCardInput[]
    connectOrCreate?: CardTransactionCreateOrConnectWithoutSenderCardInput | CardTransactionCreateOrConnectWithoutSenderCardInput[]
    upsert?: CardTransactionUpsertWithWhereUniqueWithoutSenderCardInput | CardTransactionUpsertWithWhereUniqueWithoutSenderCardInput[]
    createMany?: CardTransactionCreateManySenderCardInputEnvelope
    set?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    disconnect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    delete?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    connect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    update?: CardTransactionUpdateWithWhereUniqueWithoutSenderCardInput | CardTransactionUpdateWithWhereUniqueWithoutSenderCardInput[]
    updateMany?: CardTransactionUpdateManyWithWhereWithoutSenderCardInput | CardTransactionUpdateManyWithWhereWithoutSenderCardInput[]
    deleteMany?: CardTransactionScalarWhereInput | CardTransactionScalarWhereInput[]
  }

  export type CardTransactionUpdateManyWithoutReceiverCardNestedInput = {
    create?: XOR<CardTransactionCreateWithoutReceiverCardInput, CardTransactionUncheckedCreateWithoutReceiverCardInput> | CardTransactionCreateWithoutReceiverCardInput[] | CardTransactionUncheckedCreateWithoutReceiverCardInput[]
    connectOrCreate?: CardTransactionCreateOrConnectWithoutReceiverCardInput | CardTransactionCreateOrConnectWithoutReceiverCardInput[]
    upsert?: CardTransactionUpsertWithWhereUniqueWithoutReceiverCardInput | CardTransactionUpsertWithWhereUniqueWithoutReceiverCardInput[]
    createMany?: CardTransactionCreateManyReceiverCardInputEnvelope
    set?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    disconnect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    delete?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    connect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    update?: CardTransactionUpdateWithWhereUniqueWithoutReceiverCardInput | CardTransactionUpdateWithWhereUniqueWithoutReceiverCardInput[]
    updateMany?: CardTransactionUpdateManyWithWhereWithoutReceiverCardInput | CardTransactionUpdateManyWithWhereWithoutReceiverCardInput[]
    deleteMany?: CardTransactionScalarWhereInput | CardTransactionScalarWhereInput[]
  }

  export type CardTransactionUncheckedUpdateManyWithoutSenderCardNestedInput = {
    create?: XOR<CardTransactionCreateWithoutSenderCardInput, CardTransactionUncheckedCreateWithoutSenderCardInput> | CardTransactionCreateWithoutSenderCardInput[] | CardTransactionUncheckedCreateWithoutSenderCardInput[]
    connectOrCreate?: CardTransactionCreateOrConnectWithoutSenderCardInput | CardTransactionCreateOrConnectWithoutSenderCardInput[]
    upsert?: CardTransactionUpsertWithWhereUniqueWithoutSenderCardInput | CardTransactionUpsertWithWhereUniqueWithoutSenderCardInput[]
    createMany?: CardTransactionCreateManySenderCardInputEnvelope
    set?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    disconnect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    delete?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    connect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    update?: CardTransactionUpdateWithWhereUniqueWithoutSenderCardInput | CardTransactionUpdateWithWhereUniqueWithoutSenderCardInput[]
    updateMany?: CardTransactionUpdateManyWithWhereWithoutSenderCardInput | CardTransactionUpdateManyWithWhereWithoutSenderCardInput[]
    deleteMany?: CardTransactionScalarWhereInput | CardTransactionScalarWhereInput[]
  }

  export type CardTransactionUncheckedUpdateManyWithoutReceiverCardNestedInput = {
    create?: XOR<CardTransactionCreateWithoutReceiverCardInput, CardTransactionUncheckedCreateWithoutReceiverCardInput> | CardTransactionCreateWithoutReceiverCardInput[] | CardTransactionUncheckedCreateWithoutReceiverCardInput[]
    connectOrCreate?: CardTransactionCreateOrConnectWithoutReceiverCardInput | CardTransactionCreateOrConnectWithoutReceiverCardInput[]
    upsert?: CardTransactionUpsertWithWhereUniqueWithoutReceiverCardInput | CardTransactionUpsertWithWhereUniqueWithoutReceiverCardInput[]
    createMany?: CardTransactionCreateManyReceiverCardInputEnvelope
    set?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    disconnect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    delete?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    connect?: CardTransactionWhereUniqueInput | CardTransactionWhereUniqueInput[]
    update?: CardTransactionUpdateWithWhereUniqueWithoutReceiverCardInput | CardTransactionUpdateWithWhereUniqueWithoutReceiverCardInput[]
    updateMany?: CardTransactionUpdateManyWithWhereWithoutReceiverCardInput | CardTransactionUpdateManyWithWhereWithoutReceiverCardInput[]
    deleteMany?: CardTransactionScalarWhereInput | CardTransactionScalarWhereInput[]
  }

  export type CardsCreateNestedOneWithoutSentTransactionsInput = {
    create?: XOR<CardsCreateWithoutSentTransactionsInput, CardsUncheckedCreateWithoutSentTransactionsInput>
    connectOrCreate?: CardsCreateOrConnectWithoutSentTransactionsInput
    connect?: CardsWhereUniqueInput
  }

  export type CardsCreateNestedOneWithoutReceivedTransactionsInput = {
    create?: XOR<CardsCreateWithoutReceivedTransactionsInput, CardsUncheckedCreateWithoutReceivedTransactionsInput>
    connectOrCreate?: CardsCreateOrConnectWithoutReceivedTransactionsInput
    connect?: CardsWhereUniqueInput
  }

  export type CardsUpdateOneRequiredWithoutSentTransactionsNestedInput = {
    create?: XOR<CardsCreateWithoutSentTransactionsInput, CardsUncheckedCreateWithoutSentTransactionsInput>
    connectOrCreate?: CardsCreateOrConnectWithoutSentTransactionsInput
    upsert?: CardsUpsertWithoutSentTransactionsInput
    connect?: CardsWhereUniqueInput
    update?: XOR<XOR<CardsUpdateToOneWithWhereWithoutSentTransactionsInput, CardsUpdateWithoutSentTransactionsInput>, CardsUncheckedUpdateWithoutSentTransactionsInput>
  }

  export type CardsUpdateOneRequiredWithoutReceivedTransactionsNestedInput = {
    create?: XOR<CardsCreateWithoutReceivedTransactionsInput, CardsUncheckedCreateWithoutReceivedTransactionsInput>
    connectOrCreate?: CardsCreateOrConnectWithoutReceivedTransactionsInput
    upsert?: CardsUpsertWithoutReceivedTransactionsInput
    connect?: CardsWhereUniqueInput
    update?: XOR<XOR<CardsUpdateToOneWithWhereWithoutReceivedTransactionsInput, CardsUpdateWithoutReceivedTransactionsInput>, CardsUncheckedUpdateWithoutReceivedTransactionsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UsersCreateWithoutSentMessagesInput = {
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Loans?: LoansCreateNestedManyWithoutUsersInput
    Deposits?: DepositsCreateNestedManyWithoutUsersInput
    Cards?: CardsCreateNestedManyWithoutUsersInput
    ReceivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UsersUncheckedCreateWithoutSentMessagesInput = {
    id?: number
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Loans?: LoansUncheckedCreateNestedManyWithoutUsersInput
    Deposits?: DepositsUncheckedCreateNestedManyWithoutUsersInput
    Cards?: CardsUncheckedCreateNestedManyWithoutUsersInput
    ReceivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UsersCreateOrConnectWithoutSentMessagesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutSentMessagesInput, UsersUncheckedCreateWithoutSentMessagesInput>
  }

  export type UsersCreateWithoutReceivedMessagesInput = {
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Loans?: LoansCreateNestedManyWithoutUsersInput
    Deposits?: DepositsCreateNestedManyWithoutUsersInput
    Cards?: CardsCreateNestedManyWithoutUsersInput
    SentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UsersUncheckedCreateWithoutReceivedMessagesInput = {
    id?: number
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Loans?: LoansUncheckedCreateNestedManyWithoutUsersInput
    Deposits?: DepositsUncheckedCreateNestedManyWithoutUsersInput
    Cards?: CardsUncheckedCreateNestedManyWithoutUsersInput
    SentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UsersCreateOrConnectWithoutReceivedMessagesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutReceivedMessagesInput, UsersUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UsersUpsertWithoutSentMessagesInput = {
    update: XOR<UsersUpdateWithoutSentMessagesInput, UsersUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UsersCreateWithoutSentMessagesInput, UsersUncheckedCreateWithoutSentMessagesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutSentMessagesInput, UsersUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UsersUpdateWithoutSentMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Loans?: LoansUpdateManyWithoutUsersNestedInput
    Deposits?: DepositsUpdateManyWithoutUsersNestedInput
    Cards?: CardsUpdateManyWithoutUsersNestedInput
    ReceivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UsersUncheckedUpdateWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Loans?: LoansUncheckedUpdateManyWithoutUsersNestedInput
    Deposits?: DepositsUncheckedUpdateManyWithoutUsersNestedInput
    Cards?: CardsUncheckedUpdateManyWithoutUsersNestedInput
    ReceivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UsersUpsertWithoutReceivedMessagesInput = {
    update: XOR<UsersUpdateWithoutReceivedMessagesInput, UsersUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UsersCreateWithoutReceivedMessagesInput, UsersUncheckedCreateWithoutReceivedMessagesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutReceivedMessagesInput, UsersUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UsersUpdateWithoutReceivedMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Loans?: LoansUpdateManyWithoutUsersNestedInput
    Deposits?: DepositsUpdateManyWithoutUsersNestedInput
    Cards?: CardsUpdateManyWithoutUsersNestedInput
    SentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UsersUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Loans?: LoansUncheckedUpdateManyWithoutUsersNestedInput
    Deposits?: DepositsUncheckedUpdateManyWithoutUsersNestedInput
    Cards?: CardsUncheckedUpdateManyWithoutUsersNestedInput
    SentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type LoansCreateWithoutUsersInput = {
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    monthly_payment_amount?: number | null
    outstanding_principal?: number | null
    paid_amount?: number | null
    next_payment_due_date?: Date | string | null
    last_payment_date?: Date | string | null
    activated_at?: Date | string | null
    accrued_penalty?: number | null
    last_penalty_calculation_date?: Date | string | null
    LoanPayments?: LoanPaymentCreateNestedManyWithoutLoanInput
  }

  export type LoansUncheckedCreateWithoutUsersInput = {
    id?: number
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    monthly_payment_amount?: number | null
    outstanding_principal?: number | null
    paid_amount?: number | null
    next_payment_due_date?: Date | string | null
    last_payment_date?: Date | string | null
    activated_at?: Date | string | null
    accrued_penalty?: number | null
    last_penalty_calculation_date?: Date | string | null
    LoanPayments?: LoanPaymentUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoansCreateOrConnectWithoutUsersInput = {
    where: LoansWhereUniqueInput
    create: XOR<LoansCreateWithoutUsersInput, LoansUncheckedCreateWithoutUsersInput>
  }

  export type LoansCreateManyUsersInputEnvelope = {
    data: LoansCreateManyUsersInput | LoansCreateManyUsersInput[]
  }

  export type DepositsCreateWithoutUsersInput = {
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    approved_at?: Date | string | null
    maturity_date?: Date | string | null
    closed_at?: Date | string | null
    calculated_accrued_interest?: number | null
    calculated_total_payout?: number | null
    early_withdrawal_requested_at?: Date | string | null
    early_withdrawal_penalty_percent?: number | null
  }

  export type DepositsUncheckedCreateWithoutUsersInput = {
    id?: number
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    approved_at?: Date | string | null
    maturity_date?: Date | string | null
    closed_at?: Date | string | null
    calculated_accrued_interest?: number | null
    calculated_total_payout?: number | null
    early_withdrawal_requested_at?: Date | string | null
    early_withdrawal_penalty_percent?: number | null
  }

  export type DepositsCreateOrConnectWithoutUsersInput = {
    where: DepositsWhereUniqueInput
    create: XOR<DepositsCreateWithoutUsersInput, DepositsUncheckedCreateWithoutUsersInput>
  }

  export type DepositsCreateManyUsersInputEnvelope = {
    data: DepositsCreateManyUsersInput | DepositsCreateManyUsersInput[]
  }

  export type CardsCreateWithoutUsersInput = {
    card_number: string
    cvv: number
    pin: number
    balance: number
    dueDate: string
    status?: string
    SentTransactions?: CardTransactionCreateNestedManyWithoutSenderCardInput
    ReceivedTransactions?: CardTransactionCreateNestedManyWithoutReceiverCardInput
  }

  export type CardsUncheckedCreateWithoutUsersInput = {
    id?: number
    card_number: string
    cvv: number
    pin: number
    balance: number
    dueDate: string
    status?: string
    SentTransactions?: CardTransactionUncheckedCreateNestedManyWithoutSenderCardInput
    ReceivedTransactions?: CardTransactionUncheckedCreateNestedManyWithoutReceiverCardInput
  }

  export type CardsCreateOrConnectWithoutUsersInput = {
    where: CardsWhereUniqueInput
    create: XOR<CardsCreateWithoutUsersInput, CardsUncheckedCreateWithoutUsersInput>
  }

  export type CardsCreateManyUsersInputEnvelope = {
    data: CardsCreateManyUsersInput | CardsCreateManyUsersInput[]
  }

  export type ChatMessageCreateWithoutSenderInput = {
    content: string
    createdAt?: Date | string
    Receiver: UsersCreateNestedOneWithoutReceivedMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutSenderInput = {
    id?: number
    receiverId: number
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageCreateManySenderInputEnvelope = {
    data: ChatMessageCreateManySenderInput | ChatMessageCreateManySenderInput[]
  }

  export type ChatMessageCreateWithoutReceiverInput = {
    content: string
    createdAt?: Date | string
    Sender: UsersCreateNestedOneWithoutSentMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutReceiverInput = {
    id?: number
    senderId: number
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput>
  }

  export type ChatMessageCreateManyReceiverInputEnvelope = {
    data: ChatMessageCreateManyReceiverInput | ChatMessageCreateManyReceiverInput[]
  }

  export type LoansUpsertWithWhereUniqueWithoutUsersInput = {
    where: LoansWhereUniqueInput
    update: XOR<LoansUpdateWithoutUsersInput, LoansUncheckedUpdateWithoutUsersInput>
    create: XOR<LoansCreateWithoutUsersInput, LoansUncheckedCreateWithoutUsersInput>
  }

  export type LoansUpdateWithWhereUniqueWithoutUsersInput = {
    where: LoansWhereUniqueInput
    data: XOR<LoansUpdateWithoutUsersInput, LoansUncheckedUpdateWithoutUsersInput>
  }

  export type LoansUpdateManyWithWhereWithoutUsersInput = {
    where: LoansScalarWhereInput
    data: XOR<LoansUpdateManyMutationInput, LoansUncheckedUpdateManyWithoutUsersInput>
  }

  export type LoansScalarWhereInput = {
    AND?: LoansScalarWhereInput | LoansScalarWhereInput[]
    OR?: LoansScalarWhereInput[]
    NOT?: LoansScalarWhereInput | LoansScalarWhereInput[]
    id?: IntFilter<"Loans"> | number
    user_id?: IntFilter<"Loans"> | number
    amount?: FloatFilter<"Loans"> | number
    interest_rate?: FloatFilter<"Loans"> | number
    term?: IntFilter<"Loans"> | number
    status?: StringFilter<"Loans"> | string
    created_at?: DateTimeFilter<"Loans"> | Date | string
    monthly_payment_amount?: FloatNullableFilter<"Loans"> | number | null
    outstanding_principal?: FloatNullableFilter<"Loans"> | number | null
    paid_amount?: FloatNullableFilter<"Loans"> | number | null
    next_payment_due_date?: DateTimeNullableFilter<"Loans"> | Date | string | null
    last_payment_date?: DateTimeNullableFilter<"Loans"> | Date | string | null
    activated_at?: DateTimeNullableFilter<"Loans"> | Date | string | null
    accrued_penalty?: FloatNullableFilter<"Loans"> | number | null
    last_penalty_calculation_date?: DateTimeNullableFilter<"Loans"> | Date | string | null
  }

  export type DepositsUpsertWithWhereUniqueWithoutUsersInput = {
    where: DepositsWhereUniqueInput
    update: XOR<DepositsUpdateWithoutUsersInput, DepositsUncheckedUpdateWithoutUsersInput>
    create: XOR<DepositsCreateWithoutUsersInput, DepositsUncheckedCreateWithoutUsersInput>
  }

  export type DepositsUpdateWithWhereUniqueWithoutUsersInput = {
    where: DepositsWhereUniqueInput
    data: XOR<DepositsUpdateWithoutUsersInput, DepositsUncheckedUpdateWithoutUsersInput>
  }

  export type DepositsUpdateManyWithWhereWithoutUsersInput = {
    where: DepositsScalarWhereInput
    data: XOR<DepositsUpdateManyMutationInput, DepositsUncheckedUpdateManyWithoutUsersInput>
  }

  export type DepositsScalarWhereInput = {
    AND?: DepositsScalarWhereInput | DepositsScalarWhereInput[]
    OR?: DepositsScalarWhereInput[]
    NOT?: DepositsScalarWhereInput | DepositsScalarWhereInput[]
    id?: IntFilter<"Deposits"> | number
    user_id?: IntFilter<"Deposits"> | number
    amount?: FloatFilter<"Deposits"> | number
    interest_rate?: FloatFilter<"Deposits"> | number
    term?: IntFilter<"Deposits"> | number
    status?: StringFilter<"Deposits"> | string
    created_at?: DateTimeFilter<"Deposits"> | Date | string
    approved_at?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    maturity_date?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    closed_at?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    calculated_accrued_interest?: FloatNullableFilter<"Deposits"> | number | null
    calculated_total_payout?: FloatNullableFilter<"Deposits"> | number | null
    early_withdrawal_requested_at?: DateTimeNullableFilter<"Deposits"> | Date | string | null
    early_withdrawal_penalty_percent?: FloatNullableFilter<"Deposits"> | number | null
  }

  export type CardsUpsertWithWhereUniqueWithoutUsersInput = {
    where: CardsWhereUniqueInput
    update: XOR<CardsUpdateWithoutUsersInput, CardsUncheckedUpdateWithoutUsersInput>
    create: XOR<CardsCreateWithoutUsersInput, CardsUncheckedCreateWithoutUsersInput>
  }

  export type CardsUpdateWithWhereUniqueWithoutUsersInput = {
    where: CardsWhereUniqueInput
    data: XOR<CardsUpdateWithoutUsersInput, CardsUncheckedUpdateWithoutUsersInput>
  }

  export type CardsUpdateManyWithWhereWithoutUsersInput = {
    where: CardsScalarWhereInput
    data: XOR<CardsUpdateManyMutationInput, CardsUncheckedUpdateManyWithoutUsersInput>
  }

  export type CardsScalarWhereInput = {
    AND?: CardsScalarWhereInput | CardsScalarWhereInput[]
    OR?: CardsScalarWhereInput[]
    NOT?: CardsScalarWhereInput | CardsScalarWhereInput[]
    id?: IntFilter<"Cards"> | number
    card_number?: StringFilter<"Cards"> | string
    cvv?: IntFilter<"Cards"> | number
    holder_id?: IntFilter<"Cards"> | number
    pin?: IntFilter<"Cards"> | number
    balance?: FloatFilter<"Cards"> | number
    dueDate?: StringFilter<"Cards"> | string
    status?: StringFilter<"Cards"> | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    senderId?: IntFilter<"ChatMessage"> | number
    receiverId?: IntFilter<"ChatMessage"> | number
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutReceiverInput, ChatMessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutReceiverInput, ChatMessageUncheckedUpdateWithoutReceiverInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutReceiverInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type UsersCreateWithoutLoansInput = {
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Deposits?: DepositsCreateNestedManyWithoutUsersInput
    Cards?: CardsCreateNestedManyWithoutUsersInput
    SentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UsersUncheckedCreateWithoutLoansInput = {
    id?: number
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Deposits?: DepositsUncheckedCreateNestedManyWithoutUsersInput
    Cards?: CardsUncheckedCreateNestedManyWithoutUsersInput
    SentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UsersCreateOrConnectWithoutLoansInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutLoansInput, UsersUncheckedCreateWithoutLoansInput>
  }

  export type LoanPaymentCreateWithoutLoanInput = {
    payment_date?: Date | string
    amount_paid: number
    principal_paid: number
    interest_paid: number
    outstanding_principal_after_payment: number
    notes?: string | null
  }

  export type LoanPaymentUncheckedCreateWithoutLoanInput = {
    id?: number
    payment_date?: Date | string
    amount_paid: number
    principal_paid: number
    interest_paid: number
    outstanding_principal_after_payment: number
    notes?: string | null
  }

  export type LoanPaymentCreateOrConnectWithoutLoanInput = {
    where: LoanPaymentWhereUniqueInput
    create: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput>
  }

  export type LoanPaymentCreateManyLoanInputEnvelope = {
    data: LoanPaymentCreateManyLoanInput | LoanPaymentCreateManyLoanInput[]
  }

  export type UsersUpsertWithoutLoansInput = {
    update: XOR<UsersUpdateWithoutLoansInput, UsersUncheckedUpdateWithoutLoansInput>
    create: XOR<UsersCreateWithoutLoansInput, UsersUncheckedCreateWithoutLoansInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutLoansInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutLoansInput, UsersUncheckedUpdateWithoutLoansInput>
  }

  export type UsersUpdateWithoutLoansInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Deposits?: DepositsUpdateManyWithoutUsersNestedInput
    Cards?: CardsUpdateManyWithoutUsersNestedInput
    SentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    ReceivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UsersUncheckedUpdateWithoutLoansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Deposits?: DepositsUncheckedUpdateManyWithoutUsersNestedInput
    Cards?: CardsUncheckedUpdateManyWithoutUsersNestedInput
    SentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    ReceivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type LoanPaymentUpsertWithWhereUniqueWithoutLoanInput = {
    where: LoanPaymentWhereUniqueInput
    update: XOR<LoanPaymentUpdateWithoutLoanInput, LoanPaymentUncheckedUpdateWithoutLoanInput>
    create: XOR<LoanPaymentCreateWithoutLoanInput, LoanPaymentUncheckedCreateWithoutLoanInput>
  }

  export type LoanPaymentUpdateWithWhereUniqueWithoutLoanInput = {
    where: LoanPaymentWhereUniqueInput
    data: XOR<LoanPaymentUpdateWithoutLoanInput, LoanPaymentUncheckedUpdateWithoutLoanInput>
  }

  export type LoanPaymentUpdateManyWithWhereWithoutLoanInput = {
    where: LoanPaymentScalarWhereInput
    data: XOR<LoanPaymentUpdateManyMutationInput, LoanPaymentUncheckedUpdateManyWithoutLoanInput>
  }

  export type LoanPaymentScalarWhereInput = {
    AND?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
    OR?: LoanPaymentScalarWhereInput[]
    NOT?: LoanPaymentScalarWhereInput | LoanPaymentScalarWhereInput[]
    id?: IntFilter<"LoanPayment"> | number
    loan_id?: IntFilter<"LoanPayment"> | number
    payment_date?: DateTimeFilter<"LoanPayment"> | Date | string
    amount_paid?: FloatFilter<"LoanPayment"> | number
    principal_paid?: FloatFilter<"LoanPayment"> | number
    interest_paid?: FloatFilter<"LoanPayment"> | number
    outstanding_principal_after_payment?: FloatFilter<"LoanPayment"> | number
    notes?: StringNullableFilter<"LoanPayment"> | string | null
  }

  export type LoansCreateWithoutLoanPaymentsInput = {
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    monthly_payment_amount?: number | null
    outstanding_principal?: number | null
    paid_amount?: number | null
    next_payment_due_date?: Date | string | null
    last_payment_date?: Date | string | null
    activated_at?: Date | string | null
    accrued_penalty?: number | null
    last_penalty_calculation_date?: Date | string | null
    Users: UsersCreateNestedOneWithoutLoansInput
  }

  export type LoansUncheckedCreateWithoutLoanPaymentsInput = {
    id?: number
    user_id: number
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    monthly_payment_amount?: number | null
    outstanding_principal?: number | null
    paid_amount?: number | null
    next_payment_due_date?: Date | string | null
    last_payment_date?: Date | string | null
    activated_at?: Date | string | null
    accrued_penalty?: number | null
    last_penalty_calculation_date?: Date | string | null
  }

  export type LoansCreateOrConnectWithoutLoanPaymentsInput = {
    where: LoansWhereUniqueInput
    create: XOR<LoansCreateWithoutLoanPaymentsInput, LoansUncheckedCreateWithoutLoanPaymentsInput>
  }

  export type LoansUpsertWithoutLoanPaymentsInput = {
    update: XOR<LoansUpdateWithoutLoanPaymentsInput, LoansUncheckedUpdateWithoutLoanPaymentsInput>
    create: XOR<LoansCreateWithoutLoanPaymentsInput, LoansUncheckedCreateWithoutLoanPaymentsInput>
    where?: LoansWhereInput
  }

  export type LoansUpdateToOneWithWhereWithoutLoanPaymentsInput = {
    where?: LoansWhereInput
    data: XOR<LoansUpdateWithoutLoanPaymentsInput, LoansUncheckedUpdateWithoutLoanPaymentsInput>
  }

  export type LoansUpdateWithoutLoanPaymentsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    outstanding_principal?: NullableFloatFieldUpdateOperationsInput | number | null
    paid_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    next_payment_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accrued_penalty?: NullableFloatFieldUpdateOperationsInput | number | null
    last_penalty_calculation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutLoansNestedInput
  }

  export type LoansUncheckedUpdateWithoutLoanPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    outstanding_principal?: NullableFloatFieldUpdateOperationsInput | number | null
    paid_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    next_payment_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accrued_penalty?: NullableFloatFieldUpdateOperationsInput | number | null
    last_penalty_calculation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersCreateWithoutDepositsInput = {
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Loans?: LoansCreateNestedManyWithoutUsersInput
    Cards?: CardsCreateNestedManyWithoutUsersInput
    SentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UsersUncheckedCreateWithoutDepositsInput = {
    id?: number
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Loans?: LoansUncheckedCreateNestedManyWithoutUsersInput
    Cards?: CardsUncheckedCreateNestedManyWithoutUsersInput
    SentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UsersCreateOrConnectWithoutDepositsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutDepositsInput, UsersUncheckedCreateWithoutDepositsInput>
  }

  export type UsersUpsertWithoutDepositsInput = {
    update: XOR<UsersUpdateWithoutDepositsInput, UsersUncheckedUpdateWithoutDepositsInput>
    create: XOR<UsersCreateWithoutDepositsInput, UsersUncheckedCreateWithoutDepositsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutDepositsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutDepositsInput, UsersUncheckedUpdateWithoutDepositsInput>
  }

  export type UsersUpdateWithoutDepositsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Loans?: LoansUpdateManyWithoutUsersNestedInput
    Cards?: CardsUpdateManyWithoutUsersNestedInput
    SentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    ReceivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UsersUncheckedUpdateWithoutDepositsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Loans?: LoansUncheckedUpdateManyWithoutUsersNestedInput
    Cards?: CardsUncheckedUpdateManyWithoutUsersNestedInput
    SentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    ReceivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UsersCreateWithoutCardsInput = {
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Loans?: LoansCreateNestedManyWithoutUsersInput
    Deposits?: DepositsCreateNestedManyWithoutUsersInput
    SentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    ReceivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
  }

  export type UsersUncheckedCreateWithoutCardsInput = {
    id?: number
    name: string
    email: string
    phone_number: string
    password_hash: string
    role?: string
    Loans?: LoansUncheckedCreateNestedManyWithoutUsersInput
    Deposits?: DepositsUncheckedCreateNestedManyWithoutUsersInput
    SentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    ReceivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UsersCreateOrConnectWithoutCardsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCardsInput, UsersUncheckedCreateWithoutCardsInput>
  }

  export type CardTransactionCreateWithoutSenderCardInput = {
    amount: number
    timestamp?: Date | string
    description: string
    ReceiverCard: CardsCreateNestedOneWithoutReceivedTransactionsInput
  }

  export type CardTransactionUncheckedCreateWithoutSenderCardInput = {
    id?: number
    amount: number
    timestamp?: Date | string
    description: string
    receiverCardId: number
  }

  export type CardTransactionCreateOrConnectWithoutSenderCardInput = {
    where: CardTransactionWhereUniqueInput
    create: XOR<CardTransactionCreateWithoutSenderCardInput, CardTransactionUncheckedCreateWithoutSenderCardInput>
  }

  export type CardTransactionCreateManySenderCardInputEnvelope = {
    data: CardTransactionCreateManySenderCardInput | CardTransactionCreateManySenderCardInput[]
  }

  export type CardTransactionCreateWithoutReceiverCardInput = {
    amount: number
    timestamp?: Date | string
    description: string
    SenderCard: CardsCreateNestedOneWithoutSentTransactionsInput
  }

  export type CardTransactionUncheckedCreateWithoutReceiverCardInput = {
    id?: number
    amount: number
    timestamp?: Date | string
    description: string
    senderCardId: number
  }

  export type CardTransactionCreateOrConnectWithoutReceiverCardInput = {
    where: CardTransactionWhereUniqueInput
    create: XOR<CardTransactionCreateWithoutReceiverCardInput, CardTransactionUncheckedCreateWithoutReceiverCardInput>
  }

  export type CardTransactionCreateManyReceiverCardInputEnvelope = {
    data: CardTransactionCreateManyReceiverCardInput | CardTransactionCreateManyReceiverCardInput[]
  }

  export type UsersUpsertWithoutCardsInput = {
    update: XOR<UsersUpdateWithoutCardsInput, UsersUncheckedUpdateWithoutCardsInput>
    create: XOR<UsersCreateWithoutCardsInput, UsersUncheckedCreateWithoutCardsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCardsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCardsInput, UsersUncheckedUpdateWithoutCardsInput>
  }

  export type UsersUpdateWithoutCardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Loans?: LoansUpdateManyWithoutUsersNestedInput
    Deposits?: DepositsUpdateManyWithoutUsersNestedInput
    SentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    ReceivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
  }

  export type UsersUncheckedUpdateWithoutCardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Loans?: LoansUncheckedUpdateManyWithoutUsersNestedInput
    Deposits?: DepositsUncheckedUpdateManyWithoutUsersNestedInput
    SentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    ReceivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CardTransactionUpsertWithWhereUniqueWithoutSenderCardInput = {
    where: CardTransactionWhereUniqueInput
    update: XOR<CardTransactionUpdateWithoutSenderCardInput, CardTransactionUncheckedUpdateWithoutSenderCardInput>
    create: XOR<CardTransactionCreateWithoutSenderCardInput, CardTransactionUncheckedCreateWithoutSenderCardInput>
  }

  export type CardTransactionUpdateWithWhereUniqueWithoutSenderCardInput = {
    where: CardTransactionWhereUniqueInput
    data: XOR<CardTransactionUpdateWithoutSenderCardInput, CardTransactionUncheckedUpdateWithoutSenderCardInput>
  }

  export type CardTransactionUpdateManyWithWhereWithoutSenderCardInput = {
    where: CardTransactionScalarWhereInput
    data: XOR<CardTransactionUpdateManyMutationInput, CardTransactionUncheckedUpdateManyWithoutSenderCardInput>
  }

  export type CardTransactionScalarWhereInput = {
    AND?: CardTransactionScalarWhereInput | CardTransactionScalarWhereInput[]
    OR?: CardTransactionScalarWhereInput[]
    NOT?: CardTransactionScalarWhereInput | CardTransactionScalarWhereInput[]
    id?: IntFilter<"CardTransaction"> | number
    amount?: FloatFilter<"CardTransaction"> | number
    timestamp?: DateTimeFilter<"CardTransaction"> | Date | string
    description?: StringFilter<"CardTransaction"> | string
    senderCardId?: IntFilter<"CardTransaction"> | number
    receiverCardId?: IntFilter<"CardTransaction"> | number
  }

  export type CardTransactionUpsertWithWhereUniqueWithoutReceiverCardInput = {
    where: CardTransactionWhereUniqueInput
    update: XOR<CardTransactionUpdateWithoutReceiverCardInput, CardTransactionUncheckedUpdateWithoutReceiverCardInput>
    create: XOR<CardTransactionCreateWithoutReceiverCardInput, CardTransactionUncheckedCreateWithoutReceiverCardInput>
  }

  export type CardTransactionUpdateWithWhereUniqueWithoutReceiverCardInput = {
    where: CardTransactionWhereUniqueInput
    data: XOR<CardTransactionUpdateWithoutReceiverCardInput, CardTransactionUncheckedUpdateWithoutReceiverCardInput>
  }

  export type CardTransactionUpdateManyWithWhereWithoutReceiverCardInput = {
    where: CardTransactionScalarWhereInput
    data: XOR<CardTransactionUpdateManyMutationInput, CardTransactionUncheckedUpdateManyWithoutReceiverCardInput>
  }

  export type CardsCreateWithoutSentTransactionsInput = {
    card_number: string
    cvv: number
    pin: number
    balance: number
    dueDate: string
    status?: string
    Users: UsersCreateNestedOneWithoutCardsInput
    ReceivedTransactions?: CardTransactionCreateNestedManyWithoutReceiverCardInput
  }

  export type CardsUncheckedCreateWithoutSentTransactionsInput = {
    id?: number
    card_number: string
    cvv: number
    holder_id: number
    pin: number
    balance: number
    dueDate: string
    status?: string
    ReceivedTransactions?: CardTransactionUncheckedCreateNestedManyWithoutReceiverCardInput
  }

  export type CardsCreateOrConnectWithoutSentTransactionsInput = {
    where: CardsWhereUniqueInput
    create: XOR<CardsCreateWithoutSentTransactionsInput, CardsUncheckedCreateWithoutSentTransactionsInput>
  }

  export type CardsCreateWithoutReceivedTransactionsInput = {
    card_number: string
    cvv: number
    pin: number
    balance: number
    dueDate: string
    status?: string
    Users: UsersCreateNestedOneWithoutCardsInput
    SentTransactions?: CardTransactionCreateNestedManyWithoutSenderCardInput
  }

  export type CardsUncheckedCreateWithoutReceivedTransactionsInput = {
    id?: number
    card_number: string
    cvv: number
    holder_id: number
    pin: number
    balance: number
    dueDate: string
    status?: string
    SentTransactions?: CardTransactionUncheckedCreateNestedManyWithoutSenderCardInput
  }

  export type CardsCreateOrConnectWithoutReceivedTransactionsInput = {
    where: CardsWhereUniqueInput
    create: XOR<CardsCreateWithoutReceivedTransactionsInput, CardsUncheckedCreateWithoutReceivedTransactionsInput>
  }

  export type CardsUpsertWithoutSentTransactionsInput = {
    update: XOR<CardsUpdateWithoutSentTransactionsInput, CardsUncheckedUpdateWithoutSentTransactionsInput>
    create: XOR<CardsCreateWithoutSentTransactionsInput, CardsUncheckedCreateWithoutSentTransactionsInput>
    where?: CardsWhereInput
  }

  export type CardsUpdateToOneWithWhereWithoutSentTransactionsInput = {
    where?: CardsWhereInput
    data: XOR<CardsUpdateWithoutSentTransactionsInput, CardsUncheckedUpdateWithoutSentTransactionsInput>
  }

  export type CardsUpdateWithoutSentTransactionsInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneRequiredWithoutCardsNestedInput
    ReceivedTransactions?: CardTransactionUpdateManyWithoutReceiverCardNestedInput
  }

  export type CardsUncheckedUpdateWithoutSentTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    holder_id?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    ReceivedTransactions?: CardTransactionUncheckedUpdateManyWithoutReceiverCardNestedInput
  }

  export type CardsUpsertWithoutReceivedTransactionsInput = {
    update: XOR<CardsUpdateWithoutReceivedTransactionsInput, CardsUncheckedUpdateWithoutReceivedTransactionsInput>
    create: XOR<CardsCreateWithoutReceivedTransactionsInput, CardsUncheckedCreateWithoutReceivedTransactionsInput>
    where?: CardsWhereInput
  }

  export type CardsUpdateToOneWithWhereWithoutReceivedTransactionsInput = {
    where?: CardsWhereInput
    data: XOR<CardsUpdateWithoutReceivedTransactionsInput, CardsUncheckedUpdateWithoutReceivedTransactionsInput>
  }

  export type CardsUpdateWithoutReceivedTransactionsInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateOneRequiredWithoutCardsNestedInput
    SentTransactions?: CardTransactionUpdateManyWithoutSenderCardNestedInput
  }

  export type CardsUncheckedUpdateWithoutReceivedTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    holder_id?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    SentTransactions?: CardTransactionUncheckedUpdateManyWithoutSenderCardNestedInput
  }

  export type LoansCreateManyUsersInput = {
    id?: number
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    monthly_payment_amount?: number | null
    outstanding_principal?: number | null
    paid_amount?: number | null
    next_payment_due_date?: Date | string | null
    last_payment_date?: Date | string | null
    activated_at?: Date | string | null
    accrued_penalty?: number | null
    last_penalty_calculation_date?: Date | string | null
  }

  export type DepositsCreateManyUsersInput = {
    id?: number
    amount: number
    interest_rate: number
    term: number
    status?: string
    created_at?: Date | string
    approved_at?: Date | string | null
    maturity_date?: Date | string | null
    closed_at?: Date | string | null
    calculated_accrued_interest?: number | null
    calculated_total_payout?: number | null
    early_withdrawal_requested_at?: Date | string | null
    early_withdrawal_penalty_percent?: number | null
  }

  export type CardsCreateManyUsersInput = {
    id?: number
    card_number: string
    cvv: number
    pin: number
    balance: number
    dueDate: string
    status?: string
  }

  export type ChatMessageCreateManySenderInput = {
    id?: number
    receiverId: number
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageCreateManyReceiverInput = {
    id?: number
    senderId: number
    content: string
    createdAt?: Date | string
  }

  export type LoansUpdateWithoutUsersInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    outstanding_principal?: NullableFloatFieldUpdateOperationsInput | number | null
    paid_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    next_payment_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accrued_penalty?: NullableFloatFieldUpdateOperationsInput | number | null
    last_penalty_calculation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LoanPayments?: LoanPaymentUpdateManyWithoutLoanNestedInput
  }

  export type LoansUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    outstanding_principal?: NullableFloatFieldUpdateOperationsInput | number | null
    paid_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    next_payment_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accrued_penalty?: NullableFloatFieldUpdateOperationsInput | number | null
    last_penalty_calculation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LoanPayments?: LoanPaymentUncheckedUpdateManyWithoutLoanNestedInput
  }

  export type LoansUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    monthly_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    outstanding_principal?: NullableFloatFieldUpdateOperationsInput | number | null
    paid_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    next_payment_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accrued_penalty?: NullableFloatFieldUpdateOperationsInput | number | null
    last_penalty_calculation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DepositsUpdateWithoutUsersInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calculated_accrued_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculated_total_payout?: NullableFloatFieldUpdateOperationsInput | number | null
    early_withdrawal_requested_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_withdrawal_penalty_percent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DepositsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calculated_accrued_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculated_total_payout?: NullableFloatFieldUpdateOperationsInput | number | null
    early_withdrawal_requested_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_withdrawal_penalty_percent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DepositsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    interest_rate?: FloatFieldUpdateOperationsInput | number
    term?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    approved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maturity_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    calculated_accrued_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculated_total_payout?: NullableFloatFieldUpdateOperationsInput | number | null
    early_withdrawal_requested_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_withdrawal_penalty_percent?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CardsUpdateWithoutUsersInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    SentTransactions?: CardTransactionUpdateManyWithoutSenderCardNestedInput
    ReceivedTransactions?: CardTransactionUpdateManyWithoutReceiverCardNestedInput
  }

  export type CardsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    SentTransactions?: CardTransactionUncheckedUpdateManyWithoutSenderCardNestedInput
    ReceivedTransactions?: CardTransactionUncheckedUpdateManyWithoutReceiverCardNestedInput
  }

  export type CardsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    cvv?: IntFieldUpdateOperationsInput | number
    pin?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    dueDate?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Receiver?: UsersUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutReceiverInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sender?: UsersUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanPaymentCreateManyLoanInput = {
    id?: number
    payment_date?: Date | string
    amount_paid: number
    principal_paid: number
    interest_paid: number
    outstanding_principal_after_payment: number
    notes?: string | null
  }

  export type LoanPaymentUpdateWithoutLoanInput = {
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: FloatFieldUpdateOperationsInput | number
    principal_paid?: FloatFieldUpdateOperationsInput | number
    interest_paid?: FloatFieldUpdateOperationsInput | number
    outstanding_principal_after_payment?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoanPaymentUncheckedUpdateWithoutLoanInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: FloatFieldUpdateOperationsInput | number
    principal_paid?: FloatFieldUpdateOperationsInput | number
    interest_paid?: FloatFieldUpdateOperationsInput | number
    outstanding_principal_after_payment?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoanPaymentUncheckedUpdateManyWithoutLoanInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: FloatFieldUpdateOperationsInput | number
    principal_paid?: FloatFieldUpdateOperationsInput | number
    interest_paid?: FloatFieldUpdateOperationsInput | number
    outstanding_principal_after_payment?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardTransactionCreateManySenderCardInput = {
    id?: number
    amount: number
    timestamp?: Date | string
    description: string
    receiverCardId: number
  }

  export type CardTransactionCreateManyReceiverCardInput = {
    id?: number
    amount: number
    timestamp?: Date | string
    description: string
    senderCardId: number
  }

  export type CardTransactionUpdateWithoutSenderCardInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    ReceiverCard?: CardsUpdateOneRequiredWithoutReceivedTransactionsNestedInput
  }

  export type CardTransactionUncheckedUpdateWithoutSenderCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    receiverCardId?: IntFieldUpdateOperationsInput | number
  }

  export type CardTransactionUncheckedUpdateManyWithoutSenderCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    receiverCardId?: IntFieldUpdateOperationsInput | number
  }

  export type CardTransactionUpdateWithoutReceiverCardInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    SenderCard?: CardsUpdateOneRequiredWithoutSentTransactionsNestedInput
  }

  export type CardTransactionUncheckedUpdateWithoutReceiverCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    senderCardId?: IntFieldUpdateOperationsInput | number
  }

  export type CardTransactionUncheckedUpdateManyWithoutReceiverCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    senderCardId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}